<html>
<head><title>Решение систем линейных уравнений методом Гаусса</title>
<link rel="stylesheet" type="text/css" href="stylle.css">
</head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center"><center>
<table width="800" cellspacing="0" cellpadding="0">
<div align=center>
<font color="" style="font-size: 20pt"><br>
Решение систем линейных уравнений методом Гаусса</font>
</div>
<div align=left><td><br>
<p>Наиболее распространённым методом решения систем линейных уравнений является
метод Гаусса с частичным выбором ведущего элемента по столбцам. 
Первый вариант этого метода здесь реализован в виде класса SLU_Gauss, написанного 
на основе двух фортран-программ DECOMP и SOLVE из книги "Машинные методы математических вычислений" 
(Дж.Форсайт, М.Малькольм, К.Моулер). Этот класс позволяет вычислить определитель матрицы, оценить её число
обусловленности, решить систему уравнений. Для того, чтобы найти обратную
матрицу нужно n раз применить метод solve к соответствующему столбцу
единичной матрицы, при этом будет получаться столбец обратной матрицы.
</p>
<pre>typedef nat int nat;

class SLU_Gauss
{
    const nat n;
    DynArray&lt;nat> ipvt;
    DynArray2&lt;double> a;
    double cond;
// Запрет конструктора копии и оператора присваивания:
    SLU_Gauss ( SLU_Gauss & );
    void operator = ( SLU_Gauss & );
public:
    SLU_Gauss ( nat k, const double * const * a );
    bool solve ( const double * b, double * x ) const; // b[n], x[n]
    bool solve ( const double * const * a, const double * b, double * x ) const;
    double condition () const { return cond; }
    double determinant () const;
};
</pre>
<p>Конструктор класса приводит исходную матрицу к треугольному виду и
приблизительно вычисляет число обусловленности, которое здесь определено, как
произведение 1-нормы матрицы A ( вычисляется явно ) на 1-норму матрицы A<SUP>-1</SUP> 
( оценивается приближённо ). Если число обусловленности
очень большое, т.е. cond + 1 равен cond, то решать такую систему смысла нет 
и в этом случае методы solve возвращают значение false. Заметим, что в
качестве аргументов для методов solve могут быть указатели на один и тот же массив ( b и x ).
Метод solve с двумя параметрами просто решает систему уравнений, а метод solve с тремя параметрами 
( первый из которых - это указатель на исходную матрицу ) 
вначале вызывает solve с двумя параметрами, а затем уточняет результат уменьшая квадратичную норму невязки. 
В моих экспериментах заметный эффект от уточнения наблюдался в редких случаях.
</p>
<p>Второй вариант реализации метода Гаусса в отличии от первого не использует операторы new-delete:
</p>
<pre>
bool slu_gauss ( ArrRef2&lt;double> data ); // несколько правых столбцов
bool slu_gauss ( ArrRef2&lt;double> data, double * x ); // один правый столбец
</pre>
<p>Здесь квадратная матрица и столбцы свободных членов записаны в один <a href=array2d.html>двухмерный массив</a> data, 
который в процессе вычислений изменяется, и на месте правых столбцов будут находится столбцы с решениями.
</p>
<p>Следущий вариант метода Гаусса выбирает ведущие элементы по всей указанной подматрице:
</p>
<pre>
//*************************** 24.03.2011 ******************************//
//
//      Решение систем линейных уравнений методом Гаусса
//      Общий выбор ведущего элемента
//      nc - к-во столбцов в левой части системы уравнений
//      col - массив индексов столбцов
//
//*************************** 24.03.2011 ******************************//

bool slu_gauss ( ArrRef2&lt;double> data, const nat nc, ArrRef&lt;nat> col );
</pre>
<p>Исходники находятся в файле <a href="source/source.zip">mathem.cpp</a>.</p>
<p>Следущий вариант метода Гаусса выбирает ведущие элементы по строкам:
</p>
<pre>
//*************************** 19.02.2017 ******************************//
//
//      Метод исключений Гаусса.
//      Выбор ведущего элемента по строкам.
//      nRow, nCol - размеры матрицы.
//      index - массив для индексов выбранных столбцов (nCol).
//      mCol - размер подматрицы, где выбираются ведущие элементы.
//
//*************************** 02.06.2019 ******************************//

bool sluGaussRow ( IMatrix&lt;T> & data, nat nRow, nat nCol, unsigned * index, nat mCol );
bool sluGaussRow ( ArrRef2&lt;T> & data, nat nRow, nat nCol, unsigned * index, nat mCol );
</pre>
<p>Исходники находятся в файле <a href="source/source.zip">LinAlg.h</a>.</p>
<a href="rus_lin_alg.html">Наверх</a>
<pre>

</pre></td></div>
</table>
</body>
</html>
