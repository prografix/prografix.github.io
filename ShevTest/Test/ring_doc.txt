
	 ¬ычисление коэффициента увеличени€ и матрицы поворота по двум фреймам

1. »меем на входе два массива трЄхмерных точек одинаковой длины. 
Ќужно найти такое ортогональное преобразование, чтобы точки первого массива point1 перешли в точки point2.
»сходные Z координаты считаем неправильными, поэтому их вычисл€ем заново.
¬се вычислени€ направлены на то, чтобы минимизировать сумму квадратов рассто€ний на плоскости между точками point2 и
преобразованными ( повЄрнутыми ) точками point1.
2. ѕередвинем исходные точки так, чтобы в каждом массиве центр масс точек был в начале координат.
3. ¬начале считаем, что Z координаты точек point1 равны нулю. 
Ќаходим методом наименьших квадратов линейное преобразование 
( матрица 2*2 ) X,Y координат точек point1 в точки point2.
4. ѕо этой матрице ( задана векторами r1, r2 ) вычисл€ем кватернион q определ€ющий поворот в 3D.
5. ѕо кватерниону q вычисл€ем матрицу поворота 3*3.
6. ќпределим Z координаты точек point1 и их образы (point3) дл€ данной матрицы поворота
    for ( i = 0; i < point1.size(); ++i )
    {
        const Vector3d & v = point1[i];
        double t1 = point2[i].x - ( m.aa * v.x + m.ab * v.y );
        double t2 = point2[i].y - ( m.ba * v.x + m.bb * v.y );
        double z = ( m.ac * t1 + m.bc * t2 ) / ( m.ac * m.ac + m.bc * m.bc );
        point3[i] = m * Vector3d ( v.x, v.y, z );
    }
7. ѕосле определени€ Z координат сделаем уточнение кватерниона 
    SLU4<double> slu;
    slu.fill ( 0, 0 );
    for ( i = 0; i < point3.size(); ++i )
    {
        const Vector3d & v = point3[i];
        const Vector3d & u = point2[i];
        slu.aa += v.x * v.x + v.y * v.y;
        slu.ac += v.x * v.z;
        slu.ad -= v.y * v.z;
        slu.cc += v.z * v.z;
        slu.ae += u.x * v.x + u.y * v.y;
        slu.be -= u.x * v.y - u.y * v.x;
        slu.ce += u.x * v.z;
        slu.de -= u.y * v.z;
    }
    slu.bb = slu.aa;
    slu.bc = slu.ad;
    slu.bd = -slu.ac;
    slu.ca = slu.ac;
    slu.cb = slu.bc;
    slu.da = slu.ad;
    slu.db = slu.bd;
    slu.dd = slu.cc;
    Quater s;
    slu.gauss ( s.ro, s.la, s.mu, s.nu );
    s.ro = sqrt ( s.ro );
    s.la /= s.ro + s.ro;
    s.mu /= s.ro + s.ro;
    s.nu /= s.ro + s.ro;
    q = s * q;
// Ќормализаци€ кватерниона и определение коэффициента увеличени€
    u = q.norm();
// ¬ычисление матрицы поворота
    q.getMatr ( m );
}