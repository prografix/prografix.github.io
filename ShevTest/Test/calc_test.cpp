
#include "math.h"

#include "../Shev/tune.h"
#include "../Shev/mathem.h"
#include "../Shev/PseudoFile.h"
#include "../Shev/ShevArray.h"
#include "../Shev/Complex.h"

#include "display.h"

namespace {

int mu_func ( nat i )
{
    const nat n = 1000;
    int mu[n] = { 1,-1,-1, 0,-1, 1,-1, 0, 0, 1,-1, 0,-1, 1, 1, 0,-1, 0,-1, 0, //  20
                  1, 1,-1, 0, 0, 1, 0, 0,-1,-1,-1, 0, 1, 1, 1, 0,-1, 1, 1, 0, //  40
                 -1,-1,-1, 0, 0, 1,-1, 0, 0, 0, 1, 0,-1, 0, 1, 0, 1, 1,-1, 0, //  60
                 -1, 1, 0, 0, 1,-1,-1, 0, 1,-1,-1, 0,-1, 1, 0, 0, 1,-1,-1, 0, //  80
                  0, 1,-1, 0, 1, 1, 1, 0,-1, 0, 1, 0, 1, 1, 1, 0,-1, 0, 0, 0, // 100
                 -1,-1,-1, 0,-1, 1,-1, 0,-1,-1, 1, 0,-1,-1, 1, 0, 0, 1, 1, 0, // 120
                  0, 1, 1, 0, 0, 0,-1, 0, 1,-1,-1, 0, 1, 1, 0, 0,-1,-1,-1, 0, // 140
                  1, 1, 1, 0, 1, 1, 0, 0,-1, 0,-1, 0, 0,-1, 1, 0,-1, 1, 1, 0, // 160
                  1, 0,-1, 0,-1, 1,-1, 0, 0,-1, 0, 0,-1,-1, 0, 0, 1, 1,-1, 0, // 180
                 -1,-1, 1, 0, 1,-1, 1, 0, 0,-1,-1, 0,-1, 1,-1, 0,-1, 0,-1, 0, // 200
                  1, 1, 1, 0, 1, 1, 0, 0, 1, 1,-1, 0, 1, 1, 1, 0, 1, 1, 1, 0, // 220
                  1,-1,-1, 0, 0, 1,-1, 0,-1,-1,-1, 0,-1, 0, 1, 0, 1,-1,-1, 0, // 240
                 -1, 0, 0, 0, 0,-1, 1, 0, 1, 0,-1, 0, 1, 1,-1, 0,-1,-1, 1, 0, // 260
                  0, 1,-1, 0, 1,-1, 1, 0,-1, 0,-1, 0,-1, 1, 0, 0,-1, 1, 0, 0, // 280
                 -1,-1,-1, 0,-1,-1, 1, 0, 0,-1, 1, 0,-1, 0, 1, 0, 0, 1, 1, 0, // 300
                  1, 1, 1, 0, 1, 0,-1, 0, 1,-1,-1, 0,-1, 1, 0, 0,-1,-1, 1, 0, // 320
                  1,-1, 1, 0, 0, 1, 1, 0, 1, 1,-1, 0, 0, 1, 1, 0,-1, 0, 1, 0, // 340
                  1, 0, 0, 0,-1, 1,-1, 0,-1, 0, 0, 0,-1,-1, 1, 0,-1, 1,-1, 0, // 360
                  0, 1, 0, 0, 1,-1,-1, 0, 0,-1, 1, 0,-1,-1, 0, 0, 1, 0,-1, 0, // 380
                  1, 1,-1, 0,-1, 1, 0, 0,-1, 1, 1, 0, 1, 1, 1, 0,-1, 1,-1, 0, // 400
                 -1,-1, 1, 0, 0,-1, 1, 0,-1,-1, 1, 0, 1, 0, 1, 0, 1,-1,-1, 0, // 420
                 -1, 1, 0, 0, 0,-1, 1, 0,-1,-1,-1, 0,-1,-1,-1, 0, 1,-1,-1, 0, // 440
                  0,-1,-1, 0, 1, 1, 1, 0,-1, 0, 1, 0, 1, 1,-1, 0,-1, 1, 0, 0, // 460
                 -1, 1,-1, 0,-1, 1,-1, 0, 1,-1, 1, 0, 1,-1, 0, 0, 0, 1,-1, 0, // 480
                  1, 1,-1, 0, 1, 0,-1, 0, 1, 0,-1, 0, 1,-1, 0, 0, 1,-1,-1, 0, // 500
                  1, 1,-1, 0, 1,-1, 0, 0,-1, 1, 1, 0, 0, 1, 1, 0, 1,-1, 1, 0, // 520
                 -1, 0,-1, 0, 0, 1, 1, 0, 0,-1, 0, 0, 1,-1, 1, 0, 1, 1, 0, 0, // 540
                 -1, 1, 1, 0, 1, 1,-1, 0, 0, 0, 1, 0, 1, 1,-1, 0,-1, 0, 1, 0, // 560
                 -1, 1,-1, 0, 1, 1, 0, 0,-1, 1,-1, 0, 1,-1, 0, 0,-1, 0, 1, 0, // 580
                  1,-1, 1, 0, 0, 1,-1, 0, 1,-1, 1, 0,-1, 0,-1, 0, 1,-1,-1, 0, // 600
                 -1,-1, 0, 0, 0,-1,-1, 0,-1,-1, 1, 0,-1, 1,-1, 0,-1,-1,-1, 0, // 620
                  0, 1, 1, 0, 0, 1,-1, 0, 1, 0,-1, 0, 1, 1, 1, 0, 0,-1, 0, 0, // 640
                 -1,-1,-1, 0,-1,-1,-1, 0, 1, 0,-1, 0,-1,-1, 1, 0, 0,-1,-1, 0, // 660
                 -1, 1,-1, 0,-1, 0, 1, 0, 1,-1, 1, 0,-1, 1, 0, 0,-1,-1, 1, 0, // 680
                  1,-1,-1, 0, 1, 0, 1, 0, 1, 1,-1, 0, 0, 1, 1, 0, 1, 1, 1, 0, // 700
                 -1, 0, 1, 0,-1, 1, 1, 0,-1,-1, 0, 0, 1, 1,-1, 0, 1, 1,-1, 0, // 720
                  1, 0, 1, 0, 0, 0,-1, 0, 0,-1, 1, 0,-1, 1, 0, 0, 1, 0,-1, 0, // 740
                 -1,-1,-1, 0, 1, 1, 0, 0, 1, 0,-1, 0, 1,-1, 1, 0,-1, 1,-1, 0, // 760
                 -1,-1, 1, 0, 0, 1, 1, 0,-1, 1, 1, 0,-1, 0, 0, 0,-1, 1, 1, 0, // 780
                  1,-1, 0, 0, 1,-1,-1, 0, 1,-1, 1, 0, 1, 1,-1, 0,-1, 1, 1, 0, // 800
                  0, 1, 1, 0,-1,-1, 1, 0,-1, 0,-1, 0, 1,-1, 1, 0, 1, 1, 0, 0, // 820
                 -1,-1,-1, 0, 0,-1,-1, 0,-1,-1, 1, 0, 0,-1, 1, 0, 0, 1,-1, 0, // 840
                  0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0,-1,-1, 0, 0,-1, 1,-1, 0, // 860
                 -1, 1,-1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0,-1, 0, 0,-1, 1, 1, 0, // 880
                 -1, 0,-1, 0,-1, 1,-1, 0, 1,-1, 0, 0, 1,-1, 1, 0,-1, 1, 1, 0, // 900
                  1,-1,-1, 0, 1,-1,-1, 0, 0, 1,-1, 0, 1, 1,-1, 0, 1, 0,-1, 0, // 920
                  1, 1, 1, 0, 0, 1, 0, 0,-1, 1, 0, 0, 1, 1,-1, 0,-1,-1, 1, 0, // 940
                 -1,-1, 1, 0, 0,-1,-1, 0, 1, 0, 1, 0,-1, 0, 1, 0,-1, 1, 1, 0, // 960
                  0,-1, 0, 0, 1, 1,-1, 0,-1,-1,-1, 0, 1, 1, 0, 0,-1,-1, 1, 0, // 980
                  0, 1,-1, 0, 1,-1,-1, 0, 1, 0,-1, 0, 1,-1, 1, 0,-1, 1, 0, 0};//1000

    return ( i < 1 || i > n ) ? 0 : mu[i-1];
}

int la_func ( nat i )
{
    const nat n = 1000;
    int la[n] = { 1,-1,-1, 1,-1, 1,-1,-1, 1, 1,-1,-1,-1, 1, 1, 1,-1,-1,-1,-1, //  20
                  1, 1,-1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1,-1, 1, 1, 1, //  40
                 -1,-1,-1,-1,-1, 1,-1,-1, 1,-1, 1,-1,-1, 1, 1, 1, 1, 1,-1, 1, //  60
                 -1, 1,-1, 1, 1,-1,-1,-1, 1,-1,-1,-1,-1, 1,-1,-1, 1,-1,-1,-1, //  80 
                  1, 1,-1, 1, 1, 1, 1, 1,-1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1, 1, // 100
                 -1,-1,-1, 1,-1, 1,-1,-1,-1,-1, 1,-1,-1,-1, 1,-1,-1, 1, 1,-1, // 120
                  1, 1, 1,-1,-1, 1,-1,-1, 1,-1,-1, 1, 1, 1, 1, 1,-1,-1,-1, 1, // 140
                  1, 1, 1, 1, 1, 1,-1,-1,-1, 1,-1, 1,-1,-1, 1, 1,-1, 1, 1, 1, // 160
                  1,-1,-1,-1,-1, 1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1, // 180
                 -1,-1, 1, 1, 1,-1, 1,-1, 1,-1,-1,-1,-1, 1,-1, 1,-1, 1,-1,-1, // 200
                  1, 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, // 220
                  1,-1,-1, 1, 1, 1,-1, 1,-1,-1,-1, 1,-1, 1, 1,-1, 1,-1,-1, 1, // 240
                 -1,-1,-1,-1,-1,-1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1,-1,-1, 1, 1, // 260
                 -1, 1,-1,-1, 1,-1, 1,-1,-1,-1,-1,-1,-1, 1,-1, 1,-1, 1,-1,-1, // 280
                 -1,-1,-1,-1,-1,-1, 1,-1, 1,-1, 1,-1,-1, 1, 1, 1, 1, 1, 1,-1, // 300
                  1, 1, 1,-1, 1, 1,-1, 1, 1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1,-1, // 320
                  1,-1, 1, 1,-1, 1, 1, 1, 1, 1,-1,-1,-1, 1, 1, 1,-1,-1, 1, 1, // 340
                  1, 1,-1, 1,-1, 1,-1, 1,-1, 1, 1, 1,-1,-1, 1,-1,-1, 1,-1, 1, // 360
                  1, 1,-1, 1, 1,-1,-1,-1,-1,-1, 1, 1,-1,-1, 1, 1, 1,-1,-1, 1, // 380
                  1, 1,-1, 1,-1, 1,-1,-1,-1, 1, 1,-1, 1, 1, 1,-1,-1, 1,-1, 1, // 400
                 -1,-1, 1,-1,-1,-1, 1,-1,-1,-1, 1,-1, 1, 1, 1, 1, 1,-1,-1,-1, // 420
                 -1, 1,-1, 1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1, // 440
                  1,-1,-1, 1, 1, 1, 1,-1,-1,-1, 1,-1, 1, 1,-1,-1,-1, 1, 1, 1, // 460
                 -1, 1,-1,-1,-1, 1,-1,-1, 1,-1, 1, 1, 1,-1,-1, 1,-1, 1,-1,-1, // 480
                  1, 1,-1, 1, 1, 1,-1, 1, 1, 1,-1, 1, 1,-1, 1,-1, 1,-1,-1,-1, // 500
                  1, 1,-1, 1, 1,-1,-1,-1,-1, 1, 1,-1, 1, 1, 1, 1, 1,-1, 1,-1, // 520
                 -1, 1,-1,-1, 1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1, 1, 1, 1,-1, 1, // 540
                 -1, 1, 1, 1, 1, 1,-1,-1,-1, 1, 1,-1, 1, 1,-1,-1,-1, 1, 1, 1, // 560
                 -1, 1,-1, 1, 1, 1,-1, 1,-1, 1,-1, 1, 1,-1,-1, 1,-1,-1, 1, 1, // 580
                  1,-1, 1, 1, 1, 1,-1,-1, 1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1, 1, // 600
                 -1,-1,-1,-1,-1,-1,-1, 1,-1,-1, 1,-1,-1, 1,-1,-1,-1,-1,-1, 1, // 620
                  1, 1, 1, 1, 1, 1,-1,-1, 1,-1,-1, 1, 1, 1, 1, 1,-1,-1,-1, 1, // 640
                 -1,-1,-1, 1,-1,-1,-1,-1, 1, 1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, // 660
                 -1, 1,-1, 1,-1, 1, 1,-1, 1,-1, 1,-1,-1, 1,-1, 1,-1,-1, 1,-1, // 680
                  1,-1,-1,-1, 1, 1, 1,-1, 1, 1,-1,-1, 1, 1, 1,-1, 1, 1, 1,-1, // 700
                 -1,-1, 1,-1,-1, 1, 1, 1,-1,-1,-1, 1, 1, 1,-1,-1, 1, 1,-1,-1, // 720
                  1,-1, 1,-1,-1, 1,-1,-1, 1,-1, 1, 1,-1, 1, 1, 1, 1, 1,-1, 1, // 740
                 -1,-1,-1,-1, 1, 1,-1, 1, 1,-1,-1,-1, 1,-1, 1, 1,-1, 1,-1,-1, // 760
                 -1,-1, 1,-1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1, 1,-1, 1, 1,-1, // 780
                  1,-1, 1, 1, 1,-1,-1,-1, 1,-1, 1, 1, 1, 1,-1,-1,-1, 1, 1,-1, // 800
                 -1, 1, 1, 1,-1,-1, 1, 1,-1, 1,-1, 1, 1,-1, 1, 1, 1, 1, 1, 1, // 820
                 -1,-1,-1, 1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1, 1, 1, 1, 1,-1, 1, // 840
                  1, 1, 1,-1,-1, 1,-1,-1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1,-1, 1, // 860
                 -1, 1,-1, 1, 1, 1,-1, 1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1, 1, 1, // 880
                 -1,-1,-1, 1,-1, 1,-1,-1, 1,-1,-1,-1, 1,-1, 1, 1,-1, 1, 1, 1, // 900
                  1,-1,-1, 1, 1,-1,-1,-1,-1, 1,-1, 1, 1, 1,-1,-1, 1,-1,-1,-1, // 920
                  1, 1, 1,-1,-1, 1,-1, 1,-1, 1,-1,-1, 1, 1,-1, 1,-1,-1, 1, 1, // 940
                 -1,-1, 1,-1,-1,-1,-1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1, 1, // 960
                  1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1, 1, 1, 1,-1,-1,-1, 1,-1, // 980
                 -1, 1,-1,-1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1, 1, 1,-1, 1, 1, 1}; // 1000

    return ( i < 1 || i > n ) ? 0 : la[i-1];
}

void mu_gen ()
{
    nat32 i, j;
    const nat n = 300;
    Suite<int> a ( n, n );
    Suite<bit8> text;
    PseudoWriteFile file ( text );
    for ( i = 0; i < n; ++i ) a[i] = mu_func ( i + 1 );
    for ( i = 1; i <= 700; ++i )
    {
        a.inc() = 0;
        int sum = 1;
        nat m = a.size();
        for ( j = 2; j < m; ++j )
        {
            if ( m % j == 0 ) sum += a[j-1];
        }
        a.las() = -sum;
        if ( i % 20 == 1 ) printf ( file, "                 " );
        switch ( sum )
        {
        case 1: printf ( file, "-1," ); break;
        case 0: printf ( file, " 0," ); break;
        case -1:printf ( file, " 1," ); break;
        }
        if ( i % 20 == 0 )
        {
            printf ( file, " // % 3d\n", 300+i );
        }
    }
    text.add ( 0 );
    display << (char *) text() << NL;
}

void la_gen ()
{
    nat32 i, j;
    const nat n = 300;
    Suite<int> a ( n, n );
    Suite<bit8> text;
    PseudoWriteFile file ( text );
    for ( i = 0; i < n; ++i ) a[i] = la_func ( i + 1 );
    for ( i = 1; i <= 700; ++i )
    {
        a.inc() = 0;
        nat m = a.size();
        nat s = (nat) sqrt ( m + 0.1 );
        int sum = s * s == m ? 0 : 1;
        for ( j = 2; j < m; ++j )
        {
            if ( m % j == 0 ) sum += a[j-1];
        }
        a.las() = -sum;
        if ( i % 20 == 1 ) printf ( file, "                 " );
        switch ( sum )
        {
        case 1: printf ( file, "-1," ); break;
        case 0: printf ( file, " 0," ); break;
        case -1:printf ( file, " 1," ); break;
        }
        if ( i % 20 == 0 )
        {
            printf ( file, " // % 3d\n", 300+i );
        }
    }
    text.add ( 0 );
    display << (char *) text() << NL;
}

class MuFunc
{
    Suite<int8> buf;
public:
    MuFunc()
    {
        buf.resize ( 1000 );
        for ( nat i = 0; i < buf.size(); ++i ) buf[i] = mu_func ( i+1 );
    }
    int operator() ( nat i )
    {
        while ( i > buf.size() )
        {
            buf.inc();
            int8 sum = 1;
            nat m = buf.size();
            for ( nat j = 2; j < m; ++j )
            {
                if ( m % j == 0 ) sum += buf[j-1];
            }
            buf.las() = -sum;
        }
        return buf[i-1];
    }
};

class LaFunc
{
    Suite<int8> buf;
public:
    LaFunc()
    {
        buf.resize ( 1000 );
        for ( nat i = 0; i < buf.size(); ++i ) buf[i] = la_func ( i+1 );
    }
    int operator() ( nat i )
    {
        while ( i > buf.size() )
        {
            buf.inc();
            nat m = buf.size();
            nat s = (nat) sqrt ( m + 0.1 );
            int8 sum = s * s == m ? 0 : 1;
            for ( nat j = 2; j < m; ++j )
            {
                if ( m % j == 0 ) sum += buf[j-1];
            }
            buf.las() = -sum;
        }
        return buf[i-1];
    }
};

void testMuFunc ( nat n )
{
    display << "testMuFunc begin" << NL;
    MuFunc mu;
    for ( nat i = 2; i <= n; ++i )
    {
        int sum = 1;
        for ( nat j = 2; j <= i; ++j )
        {
            if ( i % j == 0 ) sum += mu ( j );
        }
        if ( sum != 0 ) display << i << NL;
    }
    display << "testMuFunc end" << NL;
}
// Числа Бернулли
const double A[41] = { 1., -1., 1., 0., -1, 0,  1, 0, -1, 0,  5, 0, -691, 0, 7, 0, -3617, 0, 43867, 0, -174611, 0, 854513, 0, -236364091, 0, 8553103, 0, -23749461029., 0, 8615841276005., 0, -7709321041217., 0, 2577687858367., 0, -26315271553053477373., 0, 2929993913841559., 0, -261082718496449122051. };
const double B[61] = { 1.,  2., 6., 1., 30, 1, 42, 1, 30, 1, 66, 1, 2730, 1, 6, 1,   510, 1,   798, 1,     330, 1,    138, 1,       2730, 1,       6, 1,          870, 1,         14322, 1,            510, 1,             6, 1,               1919190, 1,                6, 1,                  13530, 1, 1806, 1, 690, 1, 282, 1, 46410, 1, 66, 1, 1590, 1, 798, 1, 870, 1, 354, 1, 56786730 };

// Многочлены Бернулли
double B1 ( double x ) { return x - 1./2; }
double B2 ( double x ) { return x*x - x + 1./6; }
double B3 ( double x ) { return x*x*x - 3*x*x/2 + x/2; }
double B4 ( double x ) { return x*x*x*x - 2*x*x*x + x*x - 1./30; }
double B5 ( double x ) { return x*x*x*x*x - 5*x*x*x*x/2 + 5*x*x*x/3 - x/6; }
double B6 ( double x ) { return x*x*x*x*x*x - 3*x*x*x*x*x + 5*x*x*x*x/2 - x*x/2 + 1./42.; }

/*                  Формулы

    S(i=1) 2 * x / ( x^2 + (2*M_PI*i)^2 ) = 1 / ( exp ( x ) - 1 ) - 1/x + 1/2

    S(i=0) 4 * x / ( x^2 + ((2*i+1)*M_PI)^2 ) = tanh ( x / 2 )
    f ( x ) = x * sqrt ( x ) * S(i=0) (2*i+1) * (-1)^i * exp ( - M_PI/4 * x^2 * (2*i+1)^2 )
    f ( x ) = f ( 1/x ), x > 0

    S(i=1) mu(i) * ( 1 / (exp(x/i) - 1) - i/x ) = 2 * x / ( x^2 + (2*M_PI)^2 )

    S(i=1) mu(i) / i * log ( 1 - x^i ) = -x
    S(i=1) mu(i) / i * log ( 1 + x^i ) = x - x * x
    S(i=1) mu(i) / i * log ( 2 * fabs ( sin ( i*x/2 ) ) ) = -cos(x)
    S(i=1) mu(i) / i * exp ( -x / i ) = 2 * S(i=1) mu(i) * i * x / ( (i*x)^2 + (2*M_PI)^2 ), x >= 0
    f ( x ) = sqrt ( x ) * S(i=1) mu(i) / i * exp ( - M_PI * x^2 / i^2 )
    f ( x ) = f ( 1/x ), x > 0

    S(i=0) mu(2*i+1) / (2*i+1) * arth ( x^(2*i+1) ) = x
    S(i=0) mu(2*i+1) / (2*i+1) * tanh ( x/(4*i+2) ) = 4 * x  / ( x^2 + M_PI^2 )

    S(i=0) mu(2*i+1) / (2*i+1) * (-1)^i * atan ( x^(2*i+1) ) = x
    S(i=0) mu(2*i+1) / (2*i+1) * (-1)^i / cosh ( x/(4*i+2) ) = 4 * M_PI  / ( x^2 + M_PI^2 )
    S(i=0) mu(2*i+1) / (2*i+1) * (-1)^i * arth ( sin(x*(2*i+1) ) = 2 * sin ( x )

    S(i=1) mu(i) / (i*i) * Li2 ( - x^i ) = x * x / 2 - x

*/
double zeta ( int k )
{
    double s = 1;
    for ( nat i = 2; i <= 32000; i+=1 )
    {
        double t = pow ( 1./i, k );
        s += t;
        if ( t < 1e-9 ) break;
    }
    return s;
}

double zeta2 ( int k )
{
    double s = pow ( M_2PI, k ) * fabs ( A[k] ) / B[k];
    for ( int i = 2; i <= k; i+=1 ) s /= i;
    return s / 2;
}

double func0 ( double x )
{
    double s = 0;
    for ( nat j = 0; j <= 1000; j+=1 )
    {
        nat j2 = j + j + 1;
        double zj = j & 1 ? -1 : 1;
        s += zj / sinh ( M_PI * j2 * x );
    }
    return s;
}

double func1 ( double x )
{
    double s = 0;
    for ( nat j = 0; j <= 1000; j+=1 )
    {
        nat j2 = j + j + 1;
        double zj = j & 1 ? -1 : 1;
        s += zj * ( cosh ( M_PI * j2 * x / 2 ) - 1 ) / sinh ( M_PI * j2 * x );
        if ( sinh ( M_PI * j2 * x ) > 1e16 ) break;
    }
    return s;
}

double func2 ( double x )
{
    return func0 (1/x);
}


void func_test()
{
//    LaFunc mu;
    for ( int i = 1; i <= 50; i+=1 )
    {
        double x = 0.1 * i;
        display << x << x*(0.5*func0 ( 0.5 * x ) - func0 ( x )) << 0.5 * func0 ( 0.5 / x ) - func0 ( 1/x ) << NL;
        display << x << x*func1 ( x ) << func1 ( 1/x ) << NL;
//        printf ( display.file, "%d %.7f %.7f\n", i, T ( mu, i ), T ( i ) );
    }
}

} // namespace

enum EmptyEnum {};

template <typename CTag, typename VTag = EmptyEnum> class ParList
{
public:
    virtual const void * operator () ( CTag ) { return 0; }
    virtual       void * operator () ( VTag ) { return 0; }
    template <typename T> void operator () ( CTag tag, const T * & ptr )
    {
        (*this) ( tag, (const T *) ptr );
    }
    template <typename T> void operator () ( VTag tag, T * & ptr )
    {
        (*this) ( tag, (T *) ptr );
    }
    typedef CTag _CTag;
    typedef VTag _VTag;
};

template <typename CTag, typename VTag = EmptyEnum> class BackParList
{
public:
    virtual void operator () ( ParList<CTag, VTag> * ptr ) = 0;
    typedef CTag _CTag;
    typedef VTag _VTag;
};

void calc_test ()
{
    func_test();
}
