
#include "math.h"

#include "../Shev/tune.h"
#include "../Shev/mathem.h"
#include "../Shev/PseudoFile.h"
#include "../Shev/ShevArray.h"
#include "../Shev/Complex.h"
#include "../Shev/LinAlg.h"

#include "display.h"

namespace {

int mu_func ( nat i )
{
    const nat n = 1000;
    int mu[n] = { 1,-1,-1, 0,-1, 1,-1, 0, 0, 1,-1, 0,-1, 1, 1, 0,-1, 0,-1, 0, //  20
                  1, 1,-1, 0, 0, 1, 0, 0,-1,-1,-1, 0, 1, 1, 1, 0,-1, 1, 1, 0, //  40
                 -1,-1,-1, 0, 0, 1,-1, 0, 0, 0, 1, 0,-1, 0, 1, 0, 1, 1,-1, 0, //  60
                 -1, 1, 0, 0, 1,-1,-1, 0, 1,-1,-1, 0,-1, 1, 0, 0, 1,-1,-1, 0, //  80
                  0, 1,-1, 0, 1, 1, 1, 0,-1, 0, 1, 0, 1, 1, 1, 0,-1, 0, 0, 0, // 100
                 -1,-1,-1, 0,-1, 1,-1, 0,-1,-1, 1, 0,-1,-1, 1, 0, 0, 1, 1, 0, // 120
                  0, 1, 1, 0, 0, 0,-1, 0, 1,-1,-1, 0, 1, 1, 0, 0,-1,-1,-1, 0, // 140
                  1, 1, 1, 0, 1, 1, 0, 0,-1, 0,-1, 0, 0,-1, 1, 0,-1, 1, 1, 0, // 160
                  1, 0,-1, 0,-1, 1,-1, 0, 0,-1, 0, 0,-1,-1, 0, 0, 1, 1,-1, 0, // 180
                 -1,-1, 1, 0, 1,-1, 1, 0, 0,-1,-1, 0,-1, 1,-1, 0,-1, 0,-1, 0, // 200
                  1, 1, 1, 0, 1, 1, 0, 0, 1, 1,-1, 0, 1, 1, 1, 0, 1, 1, 1, 0, // 220
                  1,-1,-1, 0, 0, 1,-1, 0,-1,-1,-1, 0,-1, 0, 1, 0, 1,-1,-1, 0, // 240
                 -1, 0, 0, 0, 0,-1, 1, 0, 1, 0,-1, 0, 1, 1,-1, 0,-1,-1, 1, 0, // 260
                  0, 1,-1, 0, 1,-1, 1, 0,-1, 0,-1, 0,-1, 1, 0, 0,-1, 1, 0, 0, // 280
                 -1,-1,-1, 0,-1,-1, 1, 0, 0,-1, 1, 0,-1, 0, 1, 0, 0, 1, 1, 0, // 300
                  1, 1, 1, 0, 1, 0,-1, 0, 1,-1,-1, 0,-1, 1, 0, 0,-1,-1, 1, 0, // 320
                  1,-1, 1, 0, 0, 1, 1, 0, 1, 1,-1, 0, 0, 1, 1, 0,-1, 0, 1, 0, // 340
                  1, 0, 0, 0,-1, 1,-1, 0,-1, 0, 0, 0,-1,-1, 1, 0,-1, 1,-1, 0, // 360
                  0, 1, 0, 0, 1,-1,-1, 0, 0,-1, 1, 0,-1,-1, 0, 0, 1, 0,-1, 0, // 380
                  1, 1,-1, 0,-1, 1, 0, 0,-1, 1, 1, 0, 1, 1, 1, 0,-1, 1,-1, 0, // 400
                 -1,-1, 1, 0, 0,-1, 1, 0,-1,-1, 1, 0, 1, 0, 1, 0, 1,-1,-1, 0, // 420
                 -1, 1, 0, 0, 0,-1, 1, 0,-1,-1,-1, 0,-1,-1,-1, 0, 1,-1,-1, 0, // 440
                  0,-1,-1, 0, 1, 1, 1, 0,-1, 0, 1, 0, 1, 1,-1, 0,-1, 1, 0, 0, // 460
                 -1, 1,-1, 0,-1, 1,-1, 0, 1,-1, 1, 0, 1,-1, 0, 0, 0, 1,-1, 0, // 480
                  1, 1,-1, 0, 1, 0,-1, 0, 1, 0,-1, 0, 1,-1, 0, 0, 1,-1,-1, 0, // 500
                  1, 1,-1, 0, 1,-1, 0, 0,-1, 1, 1, 0, 0, 1, 1, 0, 1,-1, 1, 0, // 520
                 -1, 0,-1, 0, 0, 1, 1, 0, 0,-1, 0, 0, 1,-1, 1, 0, 1, 1, 0, 0, // 540
                 -1, 1, 1, 0, 1, 1,-1, 0, 0, 0, 1, 0, 1, 1,-1, 0,-1, 0, 1, 0, // 560
                 -1, 1,-1, 0, 1, 1, 0, 0,-1, 1,-1, 0, 1,-1, 0, 0,-1, 0, 1, 0, // 580
                  1,-1, 1, 0, 0, 1,-1, 0, 1,-1, 1, 0,-1, 0,-1, 0, 1,-1,-1, 0, // 600
                 -1,-1, 0, 0, 0,-1,-1, 0,-1,-1, 1, 0,-1, 1,-1, 0,-1,-1,-1, 0, // 620
                  0, 1, 1, 0, 0, 1,-1, 0, 1, 0,-1, 0, 1, 1, 1, 0, 0,-1, 0, 0, // 640
                 -1,-1,-1, 0,-1,-1,-1, 0, 1, 0,-1, 0,-1,-1, 1, 0, 0,-1,-1, 0, // 660
                 -1, 1,-1, 0,-1, 0, 1, 0, 1,-1, 1, 0,-1, 1, 0, 0,-1,-1, 1, 0, // 680
                  1,-1,-1, 0, 1, 0, 1, 0, 1, 1,-1, 0, 0, 1, 1, 0, 1, 1, 1, 0, // 700
                 -1, 0, 1, 0,-1, 1, 1, 0,-1,-1, 0, 0, 1, 1,-1, 0, 1, 1,-1, 0, // 720
                  1, 0, 1, 0, 0, 0,-1, 0, 0,-1, 1, 0,-1, 1, 0, 0, 1, 0,-1, 0, // 740
                 -1,-1,-1, 0, 1, 1, 0, 0, 1, 0,-1, 0, 1,-1, 1, 0,-1, 1,-1, 0, // 760
                 -1,-1, 1, 0, 0, 1, 1, 0,-1, 1, 1, 0,-1, 0, 0, 0,-1, 1, 1, 0, // 780
                  1,-1, 0, 0, 1,-1,-1, 0, 1,-1, 1, 0, 1, 1,-1, 0,-1, 1, 1, 0, // 800
                  0, 1, 1, 0,-1,-1, 1, 0,-1, 0,-1, 0, 1,-1, 1, 0, 1, 1, 0, 0, // 820
                 -1,-1,-1, 0, 0,-1,-1, 0,-1,-1, 1, 0, 0,-1, 1, 0, 0, 1,-1, 0, // 840
                  0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0,-1,-1, 0, 0,-1, 1,-1, 0, // 860
                 -1, 1,-1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0,-1, 0, 0,-1, 1, 1, 0, // 880
                 -1, 0,-1, 0,-1, 1,-1, 0, 1,-1, 0, 0, 1,-1, 1, 0,-1, 1, 1, 0, // 900
                  1,-1,-1, 0, 1,-1,-1, 0, 0, 1,-1, 0, 1, 1,-1, 0, 1, 0,-1, 0, // 920
                  1, 1, 1, 0, 0, 1, 0, 0,-1, 1, 0, 0, 1, 1,-1, 0,-1,-1, 1, 0, // 940
                 -1,-1, 1, 0, 0,-1,-1, 0, 1, 0, 1, 0,-1, 0, 1, 0,-1, 1, 1, 0, // 960
                  0,-1, 0, 0, 1, 1,-1, 0,-1,-1,-1, 0, 1, 1, 0, 0,-1,-1, 1, 0, // 980
                  0, 1,-1, 0, 1,-1,-1, 0, 1, 0,-1, 0, 1,-1, 1, 0,-1, 1, 0, 0};//1000

    return ( i < 1 || i > n ) ? 0 : mu[i-1];
}

int la_func ( nat i )
{
    const nat n = 1000;
    int la[n] = { 1,-1,-1, 1,-1, 1,-1,-1, 1, 1,-1,-1,-1, 1, 1, 1,-1,-1,-1,-1, //  20
                  1, 1,-1, 1, 1, 1,-1,-1,-1,-1,-1,-1, 1, 1, 1, 1,-1, 1, 1, 1, //  40
                 -1,-1,-1,-1,-1, 1,-1,-1, 1,-1, 1,-1,-1, 1, 1, 1, 1, 1,-1, 1, //  60
                 -1, 1,-1, 1, 1,-1,-1,-1, 1,-1,-1,-1,-1, 1,-1,-1, 1,-1,-1,-1, //  80 
                  1, 1,-1, 1, 1, 1, 1, 1,-1, 1, 1,-1, 1, 1, 1, 1,-1,-1,-1, 1, // 100
                 -1,-1,-1, 1,-1, 1,-1,-1,-1,-1, 1,-1,-1,-1, 1,-1,-1, 1, 1,-1, // 120
                  1, 1, 1,-1,-1, 1,-1,-1, 1,-1,-1, 1, 1, 1, 1, 1,-1,-1,-1, 1, // 140
                  1, 1, 1, 1, 1, 1,-1,-1,-1, 1,-1, 1,-1,-1, 1, 1,-1, 1, 1, 1, // 160
                  1,-1,-1,-1,-1, 1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1, 1, 1,-1,-1, // 180
                 -1,-1, 1, 1, 1,-1, 1,-1, 1,-1,-1,-1,-1, 1,-1, 1,-1, 1,-1,-1, // 200
                  1, 1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1, 1, 1, 1, 1, 1, 1, // 220
                  1,-1,-1, 1, 1, 1,-1, 1,-1,-1,-1, 1,-1, 1, 1,-1, 1,-1,-1, 1, // 240
                 -1,-1,-1,-1,-1,-1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1,-1,-1, 1, 1, // 260
                 -1, 1,-1,-1, 1,-1, 1,-1,-1,-1,-1,-1,-1, 1,-1, 1,-1, 1,-1,-1, // 280
                 -1,-1,-1,-1,-1,-1, 1,-1, 1,-1, 1,-1,-1, 1, 1, 1, 1, 1, 1,-1, // 300
                  1, 1, 1,-1, 1, 1,-1, 1, 1,-1,-1,-1,-1, 1, 1,-1,-1,-1, 1,-1, // 320
                  1,-1, 1, 1,-1, 1, 1, 1, 1, 1,-1,-1,-1, 1, 1, 1,-1,-1, 1, 1, // 340
                  1, 1,-1, 1,-1, 1,-1, 1,-1, 1, 1, 1,-1,-1, 1,-1,-1, 1,-1, 1, // 360
                  1, 1,-1, 1, 1,-1,-1,-1,-1,-1, 1, 1,-1,-1, 1, 1, 1,-1,-1, 1, // 380
                  1, 1,-1, 1,-1, 1,-1,-1,-1, 1, 1,-1, 1, 1, 1,-1,-1, 1,-1, 1, // 400
                 -1,-1, 1,-1,-1,-1, 1,-1,-1,-1, 1,-1, 1, 1, 1, 1, 1,-1,-1,-1, // 420
                 -1, 1,-1, 1,-1,-1, 1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 1,-1,-1,-1, // 440
                  1,-1,-1, 1, 1, 1, 1,-1,-1,-1, 1,-1, 1, 1,-1,-1,-1, 1, 1, 1, // 460
                 -1, 1,-1,-1,-1, 1,-1,-1, 1,-1, 1, 1, 1,-1,-1, 1,-1, 1,-1,-1, // 480
                  1, 1,-1, 1, 1, 1,-1, 1, 1, 1,-1, 1, 1,-1, 1,-1, 1,-1,-1,-1, // 500
                  1, 1,-1, 1, 1,-1,-1,-1,-1, 1, 1,-1, 1, 1, 1, 1, 1,-1, 1,-1, // 520
                 -1, 1,-1,-1, 1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1, 1, 1, 1,-1, 1, // 540
                 -1, 1, 1, 1, 1, 1,-1,-1,-1, 1, 1,-1, 1, 1,-1,-1,-1, 1, 1, 1, // 560
                 -1, 1,-1, 1, 1, 1,-1, 1,-1, 1,-1, 1, 1,-1,-1, 1,-1,-1, 1, 1, // 580
                  1,-1, 1, 1, 1, 1,-1,-1, 1,-1, 1,-1,-1,-1,-1,-1, 1,-1,-1, 1, // 600
                 -1,-1,-1,-1,-1,-1,-1, 1,-1,-1, 1,-1,-1, 1,-1,-1,-1,-1,-1, 1, // 620
                  1, 1, 1, 1, 1, 1,-1,-1, 1,-1,-1, 1, 1, 1, 1, 1,-1,-1,-1, 1, // 640
                 -1,-1,-1, 1,-1,-1,-1,-1, 1, 1,-1,-1,-1,-1, 1,-1,-1,-1,-1,-1, // 660
                 -1, 1,-1, 1,-1, 1, 1,-1, 1,-1, 1,-1,-1, 1,-1, 1,-1,-1, 1,-1, // 680
                  1,-1,-1,-1, 1, 1, 1,-1, 1, 1,-1,-1, 1, 1, 1,-1, 1, 1, 1,-1, // 700
                 -1,-1, 1,-1,-1, 1, 1, 1,-1,-1,-1, 1, 1, 1,-1,-1, 1, 1,-1,-1, // 720
                  1,-1, 1,-1,-1, 1,-1,-1, 1,-1, 1, 1,-1, 1, 1, 1, 1, 1,-1, 1, // 740
                 -1,-1,-1,-1, 1, 1,-1, 1, 1,-1,-1,-1, 1,-1, 1, 1,-1, 1,-1,-1, // 760
                 -1,-1, 1,-1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1,-1, 1,-1, 1, 1,-1, // 780
                  1,-1, 1, 1, 1,-1,-1,-1, 1,-1, 1, 1, 1, 1,-1,-1,-1, 1, 1,-1, // 800
                 -1, 1, 1, 1,-1,-1, 1, 1,-1, 1,-1, 1, 1,-1, 1, 1, 1, 1, 1, 1, // 820
                 -1,-1,-1, 1, 1,-1,-1,-1,-1,-1, 1,-1,-1,-1, 1, 1, 1, 1,-1, 1, // 840
                  1, 1, 1,-1,-1, 1,-1,-1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1,-1, 1, // 860
                 -1, 1,-1, 1, 1, 1,-1, 1, 1, 1, 1, 1,-1,-1, 1, 1,-1, 1, 1, 1, // 880
                 -1,-1,-1, 1,-1, 1,-1,-1, 1,-1,-1,-1, 1,-1, 1, 1,-1, 1, 1, 1, // 900
                  1,-1,-1, 1, 1,-1,-1,-1,-1, 1,-1, 1, 1, 1,-1,-1, 1,-1,-1,-1, // 920
                  1, 1, 1,-1,-1, 1,-1, 1,-1, 1,-1,-1, 1, 1,-1, 1,-1,-1, 1, 1, // 940
                 -1,-1, 1,-1,-1,-1,-1, 1, 1, 1, 1,-1,-1, 1, 1,-1,-1, 1, 1, 1, // 960
                  1,-1,-1,-1, 1, 1,-1,-1,-1,-1,-1,-1, 1, 1, 1,-1,-1,-1, 1,-1, // 980
                 -1, 1,-1,-1, 1,-1,-1, 1, 1,-1,-1, 1, 1,-1, 1, 1,-1, 1, 1, 1}; // 1000

    return ( i < 1 || i > n ) ? 0 : la[i-1];
}

void mu_gen ()
{
    nat32 i, j;
    const nat n = 300;
    Suite<int> a ( n, n );
    Suite<bit8> text;
    PseudoWriteFile file ( text );
    for ( i = 0; i < n; ++i ) a[i] = mu_func ( i + 1 );
    for ( i = 1; i <= 700; ++i )
    {
        a.inc() = 0;
        int sum = 1;
        nat m = a.size();
        for ( j = 2; j < m; ++j )
        {
            if ( m % j == 0 ) sum += a[j-1];
        }
        a.las() = -sum;
        if ( i % 20 == 1 ) printf ( file, "                 " );
        switch ( sum )
        {
        case 1: printf ( file, "-1," ); break;
        case 0: printf ( file, " 0," ); break;
        case -1:printf ( file, " 1," ); break;
        }
        if ( i % 20 == 0 )
        {
            printf ( file, " // % 3d\n", 300+i );
        }
    }
    text.add ( 0 );
    display << (char *) text() << NL;
}

void la_gen ()
{
    nat32 i, j;
    const nat n = 300;
    Suite<int> a ( n, n );
    Suite<bit8> text;
    PseudoWriteFile file ( text );
    for ( i = 0; i < n; ++i ) a[i] = la_func ( i + 1 );
    for ( i = 1; i <= 700; ++i )
    {
        a.inc() = 0;
        nat m = a.size();
        nat s = (nat) sqrt ( m + 0.1 );
        int sum = s * s == m ? 0 : 1;
        for ( j = 2; j < m; ++j )
        {
            if ( m % j == 0 ) sum += a[j-1];
        }
        a.las() = -sum;
        if ( i % 20 == 1 ) printf ( file, "                 " );
        switch ( sum )
        {
        case 1: printf ( file, "-1," ); break;
        case 0: printf ( file, " 0," ); break;
        case -1:printf ( file, " 1," ); break;
        }
        if ( i % 20 == 0 )
        {
            printf ( file, " // % 3d\n", 300+i );
        }
    }
    text.add ( 0 );
    display << (char *) text() << NL;
}

class MuFunc
{
    Suite<int8> buf;
public:
    MuFunc()
    {
        buf.resize ( 1000 );
        for ( nat i = 0; i < buf.size(); ++i ) buf[i] = mu_func ( i+1 );
    }
    int operator() ( nat i )
    {
        while ( i > buf.size() )
        {
            buf.inc();
            int8 sum = 1;
            nat m = buf.size();
            for ( nat j = 2; j < m; ++j )
            {
                if ( m % j == 0 ) sum += buf[j-1];
            }
            buf.las() = -sum;
        }
        return buf[i-1];
    }
};

class LaFunc
{
    Suite<int8> buf;
public:
    LaFunc()
    {
        buf.resize ( 1000 );
        for ( nat i = 0; i < buf.size(); ++i ) buf[i] = la_func ( i+1 );
    }
    int operator() ( nat i )
    {
        while ( i > buf.size() )
        {
            buf.inc();
            nat m = buf.size();
            nat s = (nat) sqrt ( m + 0.1 );
            int8 sum = s * s == m ? 0 : 1;
            for ( nat j = 2; j < m; ++j )
            {
                if ( m % j == 0 ) sum += buf[j-1];
            }
            buf.las() = -sum;
        }
        return buf[i-1];
    }
};

void testMuFunc ( nat n )
{
    display << "testMuFunc begin" << NL;
    MuFunc mu;
    for ( nat i = 2; i <= n; ++i )
    {
        int sum = 1;
        for ( nat j = 2; j <= i; ++j )
        {
            if ( i % j == 0 ) sum += mu ( j );
        }
        if ( sum != 0 ) display << i << NL;
    }
    display << "testMuFunc end" << NL;
}
// Числа Бернулли
const double A[41] = { 1., -1., 1., 0., -1, 0,  1, 0, -1, 0,  5, 0, -691, 0, 7, 0, -3617, 0, 43867, 0, -174611, 0, 854513, 0, -236364091, 0, 8553103, 0, -23749461029., 0, 8615841276005., 0, -7709321041217., 0, 2577687858367., 0, -26315271553053477373., 0, 2929993913841559., 0, -261082718496449122051. };
const double B[61] = { 1.,  2., 6., 1., 30, 1, 42, 1, 30, 1, 66, 1, 2730, 1, 6, 1,   510, 1,   798, 1,     330, 1,    138, 1,       2730, 1,       6, 1,          870, 1,         14322, 1,            510, 1,             6, 1,               1919190, 1,                6, 1,                  13530, 1, 1806, 1, 690, 1, 282, 1, 46410, 1, 66, 1, 1590, 1, 798, 1, 870, 1, 354, 1, 56786730 };

// Многочлены Бернулли
double B1 ( double x ) { return x - 1./2; }
double B2 ( double x ) { return x*x - x + 1./6; }
double B3 ( double x ) { return x*x*x - 3*x*x/2 + x/2; }
double B4 ( double x ) { return x*x*x*x - 2*x*x*x + x*x - 1./30; }
double B5 ( double x ) { return x*x*x*x*x - 5*x*x*x*x/2 + 5*x*x*x/3 - x/6; }
double B6 ( double x ) { return x*x*x*x*x*x - 3*x*x*x*x*x + 5*x*x*x*x/2 - x*x/2 + 1./42.; }

/*                  Формулы

    S(i=1) 2 * x / ( x^2 + (2*M_PI*i)^2 ) = 1 / ( exp ( x ) - 1 ) - 1/x + 1/2

    S(i=0) 4 * x / ( x^2 + ((2*i+1)*M_PI)^2 ) = tanh ( x / 2 )
    f ( x ) = x * sqrt ( x ) * S(i=0) (2*i+1) * (-1)^i * exp ( - M_PI/4 * x^2 * (2*i+1)^2 )
    f ( x ) = f ( 1/x ), x > 0

    S(i=1) mu(i) * ( 1 / (exp(x/i) - 1) - i/x ) = 2 * x / ( x^2 + (2*M_PI)^2 )

    S(i=1) mu(i) / i * log ( 1 - x^i ) = -x
    S(i=1) mu(i) / i * log ( 1 + x^i ) = x - x * x
    S(i=1) mu(i) / i * log ( 2 * fabs ( sin ( i*x/2 ) ) ) = -cos(x)
    S(i=1) mu(i) / i * exp ( -x / i ) = 2 * S(i=1) mu(i) * i * x / ( (i*x)^2 + (2*M_PI)^2 ), x >= 0
    f ( x ) = sqrt ( x ) * S(i=1) mu(i) / i * exp ( - M_PI * x^2 / i^2 )
    f ( x ) = f ( 1/x ), x > 0

    S(i=0) mu(2*i+1) / (2*i+1) * arth ( x^(2*i+1) ) = x
    S(i=0) mu(2*i+1) / (2*i+1) * tanh ( x/(4*i+2) ) = 4 * x  / ( x^2 + M_PI^2 )

    S(i=0) mu(2*i+1) / (2*i+1) * (-1)^i * atan ( x^(2*i+1) ) = x
    S(i=0) mu(2*i+1) / (2*i+1) * (-1)^i / cosh ( x/(4*i+2) ) = 4 * M_PI  / ( x^2 + M_PI^2 )
    S(i=0) mu(2*i+1) / (2*i+1) * (-1)^i * arth ( sin(x*(2*i+1) ) = 2 * sin ( x )

    S(i=1) mu(i) / (i*i) * Li2 ( - x^i ) = x * x / 2 - x

*/
double zeta ( int k )
{
    switch ( k )
    {
    case 2:
        return 1.64493406684822643647;
    case 3:
        return 1.20205690315959428540;
    case 4:
        return 1.08232323371113819152;
    case 5:
        return 1.03692775514336992631;
    case 6:
        return 1.01734306198444913971;
    case 7:
        return 1.00834927738192282683;
    case 8:
        return 1.00407735619794433937;
    case 9:
        return 1.00200839282608221441;
    case 10:
        return 1.00099457512781808533;
    case 11:
        return 1.00049418860411946455;
    case 12:
        return 1.00024608655330804829;
    }
    double s = 1;
    for ( nat i = 2; i < 20; i+=1 )
    {
        double t = pow ( 1./i, k );
        s += t;
        if ( t < 1e-16 ) break;
    }
    return s;
}

double zeta2 ( int k )
{
    double s = pow ( M_2PI, k ) * fabs ( A[k] ) / B[k];
    for ( int i = 2; i <= k; i+=1 ) s /= i;
    return s / 2;
}

double func0 ( MuFunc & mu, double x )
{
    double s = 0;
    for ( nat n = 1; n < 30000; n+=2 )
    {
        double t = cos ( x/(M_PI2*n) )/n;
        if ( n % 4 == 1 )
            s += t;
        else
            s -= t;
//        if ( t < 1e-16 ) break;
    }
    return s/M_PI2;
}

double factor ( nat n )
{
    double s = 1;
    for ( nat i = 2; i <= n; i+=1 )
    {
        s *= i;
    }
    return s;
}

double func1 ( MuFunc & mu, double x )
{
    double s = 0;
    for ( nat n = 1; n <= 30000; n+=2 )
    {
        double t = 1 + n * x;
        t = 1 / t;
        if ( n % 4 == 1 )
            s += t;
        else
            s -= t;
    }
    return s;
}

double func2 ( MuFunc & mu )
{
    double s = 0;
    for ( nat n = 1; n <= 40000; n+=1 )
    {
        double t = _pow2 ( 1./ n );
        if(n%3==0 ) continue;
        s += mu(n) * t;
    }
display << 27/(4*M_PI*M_PI ) / s << NL;
//display << -3/(4*M_PI*M_PI ) << s << NL;
    return s;
}

double func3 ()
{
    double s = 0;
    for ( nat n = 2; n <= 40000; n+=4 )
    {
        //if(n%3==0 ) continue;
        double t = _pow2 ( 1./ (n) );
        if(n%3==2 )
            s += t;
        else
            s += t;
    }
display << s <<M_PI*M_PI/32 << NL;
    return s;
}

void func_test()
{
    MuFunc mu;
    func3 ();
    for ( int i = 1; i < 41; i+=1 )
    {
        double x = 0.1*i;
       // display << func1 (mu, x) << func0 (mu, x) <<NL;
        //printf ( display.file, "%d %.4e\n", i, s );
    }
    //display << pow (0.9,50)<<pow (0.9,30)<<NL;
}

} // namespace


void calc_test ()
{
    func_test();
}
