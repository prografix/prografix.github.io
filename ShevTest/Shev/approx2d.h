
#pragma once

#include "ShevArray.h"
#include "Vector2d.h"

//************************* 01.08.2006 ******************************//
//
//    Аппроксимация прямой набора из n двухмерных точек
//    Минимизируется абсолютный момент 1-го порядка относительно прямой
//
//************************* 01.02.2011 ******************************//

Def<Line2d> getLine1 ( CCArrRef<Vector2d> & point );

Def<Line2d> getLine1 ( CCArrRef<Vector2d> & point, CCArrRef<double> & mass );


//*******************************************************************//
//
//      Аппроксимация прямой набора из n двухмерных точек
//      Минимизируется момент 2-го порядка относительно прямой
//
//************************* 01.02.2011 ******************************//

Def<Line2d> getLine2 ( CCArrRef<Vector2d> & point );

Def<Line2d> getLine2 ( CCArrRef<Vector2d> & point, CCArrRef<double> & mass );


//************************* 30.12.2009 ******************************//
//
//      Аппроксимация прямой набора из n двухмерных точек.
//      Минимизируется максимальное расстояние от точек до прямой
//
//************************* 01.05.2019 ******************************//

Line2d getLineU ( CCArrRef<Vector2d> & point, double & r );
inline
Line2d getLineU ( CCArrRef<Vector2d> & point )
{
    double r;
    return getLineU ( point, r );
}


//************************* 11.09.2015 ******************************//
//
//      Робастный метод аппроксимации набора точек прямой
//      Заполняет массив весов (mass) значениями от 0 до 1
//
//************************* 11.12.2019 ******************************//

Def<Line2d> getLineR ( CCArrRef<Vector2d> & point, ArrRef<double> & mass );


//************************* 06.12.2006 ******************************//
//
//           Аппроксимация прямой набора из n отрезков
//      Минимизируется момент 2-го порядка относительно прямой
//
//************************* 10.01.2011 ******************************//

Def<Line2d> getLine2 ( CCArrRef<Segment2d> & segm );


//*******************************************************************//
//
//            Аппроксимация точек окружностью
//              Sum ( Ri^2 - R^2 )^2 -> min
//
//************************ 05.11.2009 *******************************//

Def<Circle2d> getCirclePnt22 ( CArrRef<Vector2d> p );


//************************ 02.05.2010 *******************************//
//
//            Аппроксимация точек окружностью
//               Sum ( Ri - R )^2 -> min
//
//************************ 02.05.2010 *******************************//

Def<Circle2d> getCirclePnt2 ( CArrRef<Vector2d> p );


//************************ 28.11.2009 *******************************//
//
//            Аппроксимация точек окружностью
//                Sum | Ri - R | -> min
//      ix1, ix2, ix3 - индексы точек задающие окружность
//
//************************ 28.11.2009 *******************************//

Def<Circle2d> getCirclePnt1 ( CArrRef<Vector2d> p, nat & ix1, nat & ix2, nat & ix3 );
Def<Circle2d> getCirclePnt1 ( CArrRef<Vector2d> p );


//************************ 20.09.2009 *******************************//
//
//             Аппроксимация многоугольника кругом
//
//************************ 06.11.2009 *******************************//

Def<Circle2d> getCirclePlg ( CArrRef<Vector2d> poly );


//************************ 11.11.2008 *******************************//
//
//             Аппроксимация многоугольника эллипсом
//
//************************ 06.11.2009 *******************************//

Def<Ellipse2d> getEllipsePlg ( CArrRef<Vector2d> poly );


//************************ 25.09.2009 *******************************//
//
//             Аппроксимация многоугольника прямоугольником
//
//************************ 06.09.2010 *******************************//

Def<Rectangle2d> getRectanglePlg ( CArrRef<Vector2d> poly );


//************************ 25.02.2023 *******************************//
//
//        Совмещение группы точек с выпуклым многоугольником
//                  при помощи сдвига, без вращения
//
//************************ 25.02.2023 *******************************//

bool minMaxPointsConvexPolygonNR ( CCArrRef<Vector2d> & point, CCArrRef<Vector2d> & vert, Vector2d & res );


//************************ 27.09.2021 *******************************//
//
//            Совмещение двух выпуклых многоугольников
//                  при помощи сдвига и вращения
//
//************************ 27.09.2021 *******************************//

Def<Conform2d> overlayConvexPolygons ( CCArrRef<Vector2d> & vert1, CCArrRef<Vector2d> & vert2 );


//************************ 07.02.2022 *******************************//
//
//        Совмещение группы точек с выпуклым многоугольником
//          при помощи преобразования сохраняющего площадь
//
//************************ 07.02.2022 *******************************//

Def<Affin2d> overlayPointsOnConvexPolygon ( CCArrRef<Vector2d> & point, CCArrRef<Line2d> & line );


//************************ 13.07.2005 *******************************//
//
//      Вычисление ближайшей точки к заданным прямым
//      Минимум суммы абсолютных расстояний ( 1-норма )
//      ix1, ix2 - индексы прямых пересечение которых даёт ответ
//
//************************ 24.05.2010 *******************************//

Def<Vector2d> getNearPoint1 ( CArrRef<Line2d> line, nat & ix1, nat & ix2 );
Def<Vector2d> getNearPoint1 ( CArrRef<Line2d> line );


//************************ 30.06.2013 *******************************//
//
//      Вычисление ближайшей точки к заданным прямым
//      Минимум p-нормы ( p = 4/3, 6/5, 8/7, 10/9 )
//
//************************ 30.06.2013 *******************************//

Def<Vector2d> getNearPoint4_3 ( CArrRef<Line2d> line );
Def<Vector2d> getNearPoint6_5 ( CArrRef<Line2d> line );
Def<Vector2d> getNearPoint8_7 ( CArrRef<Line2d> line );
Def<Vector2d> getNearPoint10_9( CArrRef<Line2d> line );


//************************ 17.01.2005 *******************************//
//
//      Вычисление ближайшей точки к заданным прямым
//      Минимум суммы квадратов расстояний ( 2-норма )
//
//************************ 02.12.2016 *******************************//

Def<Vector2d> getNearPoint2 ( CArrRef<Line2d> line );
Def<Vector2d> getNearPoint2 ( CArrRef<Line2d> line, CArrRef<double> mass );


//************************ 19.12.2009 *******************************//
//
//      Вычисление ближайшей точки к заданным прямым
//      Минимакс расстояний от точки до прямых ( бесконечная норма )
//
//************************ 02.02.2011 *******************************//

Def<Vector2d> getNearPointU ( CArrRef<Line2d> line );


//************************* 03.12.2016 ******************************//
//
//    Робастный метод вычисления ближайшей точки к заданным прямым
//    Заполняет массив весов (mass) значениями от 0 до 1
//
//************************* 11.12.2019 ******************************//

Def<Vector2d> getNearPointR ( CCArrRef<Line2d> & line, ArrRef<double> & mass );


//************************* 20.09.2008 ******************************//
//
//      Вычисление ближайшей точки к заданным точкам
//      Минимум суммы абсолютных расстояний ( 1-норма )
//      Метод "тяжёлого шарика", eps - заданная точность
//
//************************* 01.12.2009 ******************************//

Def<Vector2d> getNearPoint1 ( CArrRef<Vector2d> point, double eps = 0 );


//************************* 01.12.2009 ******************************//
//
//      Вычисление ближайшей точки к заданным точкам
//      Минимум суммы квадратов расстояний ( 2-норма )
//
//************************* 01.12.2009 ******************************//

Def<Vector2d> getNearPoint2 ( CArrRef<Vector2d> point );


//************************* 01.12.2009 ******************************//
//
//      Вычисление ближайшей точки к заданным точкам
//      Минимум максимального расстояния ( бесконечная норма )
//
//************************* 02.02.2011 ******************************//

Def<Vector2d> getNearPointU ( CArrRef<Vector2d> point );


//************************* 05.03.2017 ******************************//
//
//                     Сплайн второго порядка
//
//************************* 30.11.2021 ******************************//

class Spline2d
{
    Vector2d a, b, c;
    mutable bool isDef;
    mutable Def<double> curv;
    mutable double aa, ab, bb, aaa, abc;
public:
    Spline2d () {}
    Spline2d ( const Vector2d & p1, const Vector2d & p2, const Vector2d & n1, const Vector2d & n2 );
    Def<Vector2d> getPoint ( const Vector2d & norm ) const;
    Vector2d getPoint ( double par ) const
    {
        return c + ( b + a * par ) * par;
    }
    Vector2d getNormal ( double par ) const
    {
        return ( b + a * ( par + par ) ).rightPerpendicular().setNorm2();
    }
    Def<double> getParFromX ( double x ) const;
    Def<double> getParFromY ( double y ) const;
    double getX ( double par ) const
    {
        return c.x + ( b.x + a.x * par ) * par;
    }
    double getY ( double par ) const
    {
        return c.y + ( b.y + a.y * par ) * par;
    }
    double getLength ( double par = 1 ) const;
    double getCurvature ( double par ) const;
    double getCurvatureAvg () const;
};
