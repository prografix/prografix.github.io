
#pragma once

#include "Matrix.h"
#include "MathFunc.h"
#include "ShevArray2.h"

//*********************** 13.05.2004 ************************//
//
//                   Арифметические корни
//
//*********************** 25.06.2013 ************************//

double root3 ( double x );
double root4 ( double x );
double root5 ( double x );
double root6 ( double x );
double root7 ( double x );
double root8 ( double x );
double root9 ( double x );
double root10( double x );


//*************************************************************//
//
//    Решение алгебраических уравнений 2, 3, 4 и 5 степени.
//    Возвращаемое значение - количество найденных корней.
//
//************************ 10.08.2018 *************************//

// a * x^2 + b * x + c = 0 - общее квадратное уравнение

nat root2 ( double a, double b, double c, double x[2] );


// x^2 + a * x + b = 0 - приведённое квадратное уравнение

nat root2 ( double a, double b, double x[2] );


// x^3 + p * x + q = 0

nat root3s ( double p, double q, double * x );


// x^3 + a * x^2 + b * x + c = 0

nat root3 ( double a, double b, double c, double * x );


// x^4 + p * x^2 + q * x + r = 0

nat root4s ( double p, double q, double r, double * x );


// x^4 + a * x^3 + b * x^2 + c * x + d = 0

nat root4 ( double a, double b, double c, double d, double * x );


// x^5 + a * x^4 + b * x^3 + c * x^2 + d * x + e = 0

nat root5 ( double a, double b, double c, double d, double e, double * x );


//************************ 26.10.2006 *************************//
//
//      Решение алгебраических уравнений n-ой степени.
//
//************************ 26.10.2006 *************************//

bool rootN ( nat n, const double * p, double * r, double * i );


//*********************************************************************//
//
//      Решение систем линейных уравнений методом Гаусса
//
//*************************** 24.04.2007 ******************************//

class SLU_Gauss
{
    const nat n;
    CmbArray<nat, 80> ipvt;
    DynArray2<double> a;
    double cond;
// Запрет конструктора копии и оператора присваивания:
    SLU_Gauss ( SLU_Gauss & );
    void operator = ( SLU_Gauss & );
public:
    SLU_Gauss ( nat k, const double * const * a );
    bool solve ( const double * b, double * x ) const; // b[n], x[n]
    bool solve ( const double * const * a, const double * b, double * x ) const;
    double condition () const { return cond; }
    double determinant () const;
};


//*************************** 31.07.2010 ******************************//
//
//      Решение систем линейных уравнений методом Гаусса
//      Выбор ведущего элемента по столбцам
//
//*************************** 09.03.2011 ******************************//

bool slu_gauss ( ArrRef2<double> data ); // несколько правых столбцов
bool slu_gauss ( ArrRef2<double> data, ArrRef<double> x ); // один правый столбец


//*************************** 24.03.2011 ******************************//
//
//      Решение систем линейных уравнений методом Гаусса
//      Общий выбор ведущего элемента
//      nc - к-во столбцов в левой части системы уравнений
//      col - массив индексов столбцов
//
//*************************** 24.03.2011 ******************************//

bool slu_gauss ( ArrRef2<double> data, const nat nc, ArrRef<nat> col );


//*********************************************************************//
//
//      Решение систем линейных уравнений методом
//      ортогонализации Грама-Шмидта ( n <= m )
//
//*************************** 18.01.2007 ******************************//

bool slu_ortho ( nat n, nat m, const double * const * a, const double * b, double * x );


//*************************** 01.06.2007 ******************************//
//
//      Решение систем линейных уравнений методом
//      ортогонализации при помощи отражений ( n <= m )
//
//*************************** 01.06.2007 ******************************//

bool slu_orthoH1 ( nat n, nat m, const double * const * a, const double * b, double * x );

nat slu_orthoH1 ( const IMatrix<double> & a, const double * b, IMatrix<double> & x );


//*************************************************************//
//
//      Симметричные положительно определённые матрицы.
//              Разложение Холецкого.
//
//*************************************************************//

class SM_Chol
{
    const nat n;
    CmbArray<double, 820> g;
// Запрет конструктора копии и оператора присваивания:
    SM_Chol ( SM_Chol & );
    void operator = ( SM_Chol & );
public:
    SM_Chol ( nat k, const double * const * a );
    bool solve ( const double * b, double * x ) const; // b[n], x[n]
    double determinant () const;
};


//*************************************************************//
//
//      Симметричные положительно определённые матрицы.
//              LDLt разложение.
//
//*************************************************************//

class SM_LDLt
{
    const nat n;
    CmbArray<double, 820> g;
// Запрет конструктора копии и оператора присваивания:
    SM_LDLt ( SM_LDLt & );
    void operator = ( SM_LDLt & );
public:
    SM_LDLt ( nat k, const double * const * a );
    bool solve ( const double * b, double * x ) const; // b[n], x[n]
    double determinant () const;
};

//*********************** 08.04.2010 **************************//
//
//      Переопределённые системы линейных уравнений ( n > m ).
//      Минимум 1-нормы вектора невязок.
//
//*********************** 12.11.2011 **************************//

bool minNorm1 ( CArrRef2<double> data, ArrRef<double> x, ArrRef<nat> index );
bool minNorm1 ( CArrRef2<double> data, ArrRef<double> x );
bool minNorm1 ( CArrRef2<double> data, ArrRef<nat> index );


//*********************** 24.07.2010 **************************//
//
//      Переопределённые системы линейных уравнений ( n > m ).
//      Минимум 2-нормы вектора невязок.
//
//*********************** 12.11.2011 **************************//

bool minNorm2 ( CArrRef2<double> data, ArrRef<double> x );


//*********************** 17.07.2010 **************************//
//
//      Переопределённые системы линейных уравнений ( n > m ).
//      Минимум бесконечной нормы вектора невязок.
//
//*********************** 12.11.2011 **************************//

bool minNormU ( CArrRef2<double> data, ArrRef<double> x, ArrRef<nat> index );
bool minNormU ( CArrRef2<double> data, ArrRef<double> x );


//****************************** 07.03.2003 *********************************//
//
//      Метод наименьших квадратов ( n >= m ). Преобразования Хаусхолдера.
//
//****************************** 21.07.2012 *********************************//

class LSS_H
{
    IMatrix<double> & a;
    CmbArray<nat, 80> pivot;
    mutable CmbArray<double, 80> alpha;
// Запрет конструктора копии и оператора присваивания:
    LSS_H ( LSS_H & );
    void operator = ( LSS_H & );
public:
    LSS_H ( IMatrix<double> & a );
    bool solve ( CArrRef<double> b, ArrRef<double> x ) const; // b[a.nRow], x[a.nCol]
};

bool lss_h ( IMatrix<double> & a, CArrRef<double> b, ArrRef<double> x );


//****************************** 07.03.2003 *********************************//
//
//      Метод наименьших квадратов ( n >= m ). Oртогонализация Грама-Шмидта.
//
//****************************** 21.07.2012 *********************************//

bool ortholin ( IMatrix<double> & a, CArrRef<double> b, ArrRef<double> x );
bool ortholin ( IMatrix<double> & a, CArrRef<double> b, ArrRef<double> x, DynArrRef<double> & p );


//****************************** 19.06.2007 *********************************//
//
//          Масштабирование столбцов для решения систем уравнений
//
//****************************** 21.10.2012 *********************************//

bool columnScale ( bool (*func) ( IMatrix<double> & a, CArrRef<double> b, ArrRef<double> x ),
                   const IMatrix<double> & a, CArrRef<double> b, ArrRef<double> x );


//****************************** 23.05.2007 *********************************//
//
//          Oртогонализация заданных векторов.
//          nr - к-во заполненных строк матрицы.
//          Возвращаемое значение - ранг системы.
//
//****************************** 23.05.2007 *********************************//

nat orthogonalizationH1 ( nat nr, IMatrix<double> & mat );


//***************************************************************************//
// 
//  Метод Якоби нахождения собственных значений и собственных векторов
//                       для симметричных матриц
//    Входные данные:
//        n - размерность матрицы
//        a - исходная матрица. В процессе работы наддиагональные элементы
//            будут изменены, но их легко восстановить по поддиагональным
//    Выходные данные:
//        d - массив собственных значений
//        v - массив собственных векторов
//
//***************************************************************************//

void jacobi ( const nat n, double * const * a, double * d, double * const * v );


//************************* 20.02.2007 **************************************//
//
//        Приведение действительной матрицы к верхней форме Хессенберга
//
//************************* 20.02.2007 **************************************//

void orthes ( nat n, double * const * a );


//************************* 05.08.2006 **************************************//
//
//        Вычисление собственных значений действительной матрицы
//        заданной в верхней форме Хессенберга
//
//************************* 05.08.2006 **************************************//

bool hqr ( nat n, double * const * h, double * wr, double * wi );


//************************* 03.12.2005 **************************************//
//
//        Поиск нуля функции на заданном интервале
//        Значения функции в ax и bx должны иметь разные знаки
//
//************************* 03.12.2005 **************************************//

bool zeroin ( double ax, double bx, const MathFunc1 & func, double tol, double & res );
