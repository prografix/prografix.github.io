<html>
<head><title>Максимальный эллипс вписанный в многоугольник</title>
<link rel="stylesheet" type="text/css" href="stylle.css"></head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center">
<table width="800" cellspacing="0" cellpadding="0">
<br>
<div align=center>
<font color="" style="font-size: 20pt">Максимальный эллипс вписанный в многоугольник</font>
</div>
<div align=left><td>
<p>
<br>
Во всех алгоритмах этого раздела обход вершин многоугольника должен быть против часовой стрелки.
<br><br>&bull; Функция maxFixEllipseInConvexPolygon вписывает эллипс с заданным удлинением в выпуклый многоуольник:
<pre>Def&lt;Ellipse2d> maxFixEllipseInConvexPolygon ( double ext, CCArrRef&lt;Vector2d> & poly );
</pre>
Входные параметры: ext - удлинение эллипса ( 1e-6 <= ext <= 0.99 ) и poly - массив вершин многоугольника.
<br><br>&bull; Функция maxFixEllipseInConvexPolygonNR делает то же самое, но без вращения:
<pre>
Def&lt;Ellipse2d> maxFixEllipseInConvexPolygonNR ( double ext, CCArrRef&lt;Vector2d> & poly );
</pre>
Входные параметры: ext - удлинение эллипса ( 1e-6 <= ext <= 1e6 ).
<br><br>&bull; Функция maxFixEllipseInPolygon вписывает эллипс с заданным удлинением в невыпуклый многоугольник:
<pre>Def&lt;Ellipse2d> maxFixEllipseInPolygon ( double ext, CCArrRef&lt;Vector2d> & poly );
</pre>
Входные параметры: ext - удлинение эллипса ( 1/64 <= ext <= 64 ) и poly - массив вершин многоугольника.
<br><br>&bull; Функция maxFixEllipseInPolygonNR делает то же самое, но без вращения:
<pre>
Def&lt;Ellipse2d> maxFixEllipseInPolygonNR ( double ext, CCArrRef&lt;Vector2d> & poly );
</pre>
&bull; Функция maxEllipseInTriangleA находит эллипс максимальной площади вписанный в треугольник:
<pre>Def&lt;Ellipse2d> maxEllipseInTriangleA ( Vector2d v1, Vector2d v2, Vector2d v3 );
</pre>
&bull; Функция maxEllipseInConvexPolygonA находит эллипс максимальной площади вписанный в выпуклый многоугольник:
<pre>Def&lt;Ellipse2d> maxEllipseInConvexPolygonA ( CCArrRef&lt;Vector2d> & poly );
</pre>
Краткое описание этого алгоритма:
<br>1. Если к-во вершин многоугольника меньше трёх, то выходим из программы.
<br>2. По каждого ребра многоугольника строим прямую.
<br>3. Из полученных прямых выбираем минимальное к-во таких, чтобы они образовали ограниченную фигуру.
<br>4. Для этих прямых находим максимальный эллипс. Сами прямые, по которым строится эллипс, назовём опорными.
<br>5. Начало цикла.
<br>6. Находим прямую за пределы которой выходит текущий эллипс. Если таких прямых нет, то конец алгоритма.
<br>7. Включаем эту прямую в набор опорных. Для этого перебором этих прямых строим новый эллипс, который не выходит
за пределы данных опорных прямых. 
К-во новых опорных прямых будет от трёх до пяти ( к-во степеней свободы для эллипса ).
<br>8. Идём в начало цикла.
</p>
&bull; Функция maxEllipseInConvexPolygonANR делает то же самое, но без вращения:
<pre>Def&lt;Ellipse2d> maxEllipseInConvexPolygonANR ( CCArrRef&lt;Vector2d> & poly );
</pre>
&bull; Функция maxEllipseInPolygonA находит эллипс максимальной площади вписанный в невыпуклый многоугольник:
<pre>Def&lt;Ellipse2d> maxEllipseInPolygonA ( CCArrRef&lt;Vector2d> & poly );
</pre>
&bull; Функция maxEllipseInPolygonANR делает то же самое, но без вращения:
<pre>Def&lt;Ellipse2d> maxEllipseInPolygonANR ( CCArrRef&lt;Vector2d> & poly );
</pre>
<p>В приложении <a href="demo/demo.html">DEMO</a> показано, как применять эти функции.
</p>
<p>Описание шаблона классов CArrRef находится <a href=array.html>здесь</a>.
<br>Описание шаблона классов Def находится <a href="def.html">здесь</a>.
<br>Описание класса Vector2d находится <a href="rus_vector2d.html">здесь</a>.
<br>Описание класса Ellipse2d находится <a href="figure2d.html">здесь</a>.
<br>Исходники алгоритма находятся в файле <a href="source/source.zip">opti2d.cpp</a>.
</p>
<a href="opti2d.html">Наверх</a>
</td></div>
</table>
</div>
<p></p>
</body>
</html>
