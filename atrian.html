<html>
<head><title>Абстрактная триангуляция</title>
<link rel="stylesheet" type="text/css" href="stylle.css"></head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center"><center>
<table width="800" cellspacing="0" cellpadding="0">
<div align=center><br>
<font color="" style="font-size: 20pt">Абстрактная триангуляция</font>
</div><br>
<div align=left><td>
<p>В этом разделе представлены алгоритмы триангуляции многоугольников, которые работают только с индексами вершин,
а тип вершин и размерность пространства может быть произвольной. 
При этом среди множества различных вариантов триангуляции ищется в некотором смысле лучшая.
Для этого должна быть задана функция качества треугольника и способ, как через качество отдельных треугольников
можно получить качество всей триангуляции. 
<br>Шаблон функций maxL1 осуществляет локальную оптимизацию уже существующей триангуляции:
</p>
<pre>
template &lt;class F, class A1, class A2=A1>
class Func2a // Функция двух аргументов
{
public:
    virtual F operator () ( A1 a1, A2 a2 ) const = 0;
};

template &lt;F, class A1, class A2=A1, class A3=A2>
class Func3a // Функция трёх аргументов
{
public:
    virtual F operator () ( A1 a1, A2 a2, A3 a3 ) const = 0;
};

struct SemiRib
{
    unsigned int next;
    unsigned int twin;
    unsigned int vert;
};

template &lt;class T>
void maxL1 ( const Func3a&lt;T,nat> & quality, const Func2a&lt;T,T> & merge, ArrRef&lt;SemiRib> & rib )
...
</pre>
<p>Исходными данными являются: функтор качества треугольника, функтор слияния качеств,
количество рёбер, ссылка на массив с рёбрами.
В массиве должна быть записана какая-то триангуляция.
Причём рёбра принадлежащие к одному треугольнику должны находится последовательно,
и поле twin должно быть меньше количества рёбер только у одного ребра из пары. 
<br>Оптимизация исходной триангуляции происходит путём сравнения двух пар треугольников - существующей пары соседних
треугольников и альтернативной пары треугольников полученной перестановкой разделяющей диагонали. 
Если качество второй пары окажется больше первой, то триангуляция меняется. 
И так до тех пор пока такие пары находятся. 
Т. к. эта оптимизация локальная, то глобальный максимум может быть и не найден ( будет найден локальный ).
Этот алгоритм требует дополнительной памяти O ( n ) и времени в среднем тоже O ( n ).
Вторая оценка определена экспериментально.
</p>
<p>Шаблон функций maxG1 осуществляет глобальную оптимизацию путём перебора всех возможных вариантов триангуляции:
</p>
<pre>template &lt;class T> 
SuiteRef&lt;Set3&lt;nat> > & maxG1 ( const Func3a&lt;T,nat> & quality, const Func2a&lt;T,T> & merge, 
                               nat nv, SuiteRef&lt;Set3&lt;nat> > & res )
...
</pre>
Исходными данными являются: функтор качества треугольника, функтор слияния качеств,
количество вершин многоугольника и ссылка на массив, куда записывается результат триангуляции.
Этот алгоритм требует дополнительной памяти O ( n <sup>2</sup> ) и времени O ( n <sup>3</sup> ).
<p>Описание шаблона классов Set3 находится <a href="composition.html">здесь</a>.
<br>Описание шаблонов классов ArrRef и SuiteRef находится <a href=array.html>здесь</a>.
<br>Исходники находятся в файле <a href="source/source.zip">atrian.h</a>.
</p>
<a href="rus_geom.html">Наверх</a>
<pre>

</pre>
</td></div>
</table>
</body>
</html>
