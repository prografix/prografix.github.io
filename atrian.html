<html>
<head><title>Абстрактная триангуляция многоугольников</title><link rel="stylesheet" type="text/css" href="stylle.css"></head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center"><br>
<font color="" style="font-size: 20pt">Абстрактная триангуляция многоугольников</font>
<table width="800" cellspacing="0" cellpadding="0">
<tr><td><br>
<p>В этом разделе представлены алгоритмы триангуляции многоугольников, которые работают только с индексами вершин,
а тип вершин и размерность пространства может быть произвольной. 
При этом среди множества различных вариантов триангуляции ищется в некотором смысле лучшая. Дело в том, что два соседних треугольника
образуют четырёхугольник, у которого можно поменять диагональ. При этом качество триангуляции может улучшиться или ухудшиться.
</p>
Шаблон функций maxL1 осуществляет локальную оптимизацию уже существующей триангуляции:
<pre>
template &lt;class F, class A1, class A2=A1>
class Func2a // Функция двух аргументов
{
public:
    virtual F operator () ( A1 a1, A2 a2 ) const = 0;
};

template &lt;F, class A1, class A2=A1, class A3=A2>
class Func3a // Функция трёх аргументов
{
public:
    virtual F operator () ( A1 a1, A2 a2, A3 a3 ) const = 0;
};

struct SemiRib
{
    unsigned int next;
    unsigned int twin;
    unsigned int vert;
};

template &lt;class T>
void maxL1 ( const Func3a&lt;T,nat> & quality, const Func2a&lt;T,T> & merge, ArrRef&lt;SemiRib> & rib )
...
</pre>
<p>Исходными данными являются: функтор качества треугольника, функтор слияния качеств,
количество рёбер, ссылка на массив с рёбрами. В массиве должна быть записана какая-то триангуляция.
Причём рёбра принадлежащие к одному треугольнику должны находится последовательно,
а поле twin должно быть меньше количества рёбер только у одного ребра из пары. 
<br>Оптимизация исходной триангуляции происходит путём сравнения двух пар треугольников - существующей пары соседних
треугольников и альтернативной пары треугольников полученной перестановкой разделяющей диагонали. 
Если качество второй пары окажется больше первой, то триангуляция меняется. 
И так до тех пор пока такие пары находятся. 
Т. к. эта оптимизация локальная, то глобальный максимум может быть и не найден ( будет найден локальный ).
Этот алгоритм требует дополнительной памяти O ( n ).
</p>
<p>В начале 2025 года я написал функцию optiL, которая делает то же самое, что и maxL1, но при этом не является шаблоном,
и используемый в ней функтор IDiagFunc прямо указывает - нужно ли изменить диагональ. Для этого ему надо передать индекс полуребра
и номера граней. Имеется две функции optiL. Первая использует уже созданный массив полурёбер rib, а вторая заполняет его по
указанной триангуляции trian:
</p>
<pre>
class IDiagFunc
{
public:
    virtual IDiagFunc & link ( CArrRef&lt;SemiRib> & r ) = 0;
    virtual bool operator () ( nat r, nat s1, nat s2 ) = 0;
};

void optiL ( IDiagFunc & change, ArrRef&lt;SemiRib> & rib );
void optiL ( IDiagFunc & change, CCArrRef&lt;Set3&lt;nat> > & trian, DynArray&lt;SemiRib> & rib );
</pre>
<p>По идее шаблон maxL1 можно везде заменить на функцию optiL, но я пока это сделал в отдельных случаях.
</p>
<p>Шаблон функций maxG1 осуществляет глобальную оптимизацию путём перебора всех возможных вариантов триангуляции:
</p>
<pre>template &lt;class T> 
SuiteRef&lt;Set3&lt;nat> > & maxG1 ( const Func3a&lt;T,nat> & quality, const Func2a&lt;T,T> & merge, 
                               nat nv, SuiteRef&lt;Set3&lt;nat> > & res )
...
</pre>
Исходными данными являются: функтор качества треугольника, функтор слияния качеств,
количество вершин многоугольника и ссылка на массив, куда записывается результат триангуляции.
Этот алгоритм требует дополнительной памяти O ( n <sup>2</sup> ) и времени O ( n <sup>3</sup> ).
<p>Описание шаблона классов Set3 находится <a href="composition.html">здесь</a>.
<br>Описание шаблонов классов ArrRef и SuiteRef находится <a href=array.html>здесь</a>.
<br>Исходники находятся в файлах <a href="source/source.zip">atrian.h и atrian.cpp</a>.
</p>
<a href="rus_geom.html">Наверх</a>
</td></tr></table></div>
<pre>

</pre>
</body>
</html>
