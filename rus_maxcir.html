<html>
<head><title>Максимальная окружность вписанная в выпуклый многоугольник</title>
<link rel="stylesheet" type="text/css" href="stylle.css"></head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center"><center>
<table width="800" cellspacing="0" cellpadding="0">
<div align=center><br>
<font color="" style="font-size: 20pt">Максимальная окружность вписанная в выпуклый многоугольник</font>
</div>
<div align=left><td><br>
<p>
В этом разделе представлены алгоритмы поиска максимальной окружности вписанной в выпуклый многоугольник.
<p>
</p>
Первый из них делает это за время O(n*log(n)) в худшем случае. Идея его следующая. 
Для каждой стороны и двух её соседних строим касательную окружность. 
Затем сторону с самой маленькой окружностью отбрасываем и пересчитываем окружности для её соседних сторон. 
Действуем таким образом пока не останется только три стороны. 
Для выбора минимальной окружности будем использовать конструкцию, которую называют пирамидой ( или heap ). 
Это массив указателей с номерами от 1 до n со следующим свойством: 
объект по указателю с номером i больше или равен объекта по указателю с номером i/2. 
Поэтому объект по указателю с номером 1 является минимальным. 
Подробнее об этом можно прочитать в "Искусство программирования" 3 том или "Алгоритмы. Построение и анализ" 
(Кормен, Лейзерсон, Ривест).
</p>
<pre>
Def&lt;Circle2d> maxCircle_NlogN ( CCArrRef< Line2d > & line );
Def&lt;Circle2d> maxCircle_NlogN ( CCArrRef&lt;Vector2d> & vert );
</pre>
<p>
Этот алгоритм может быть вызван из двух функций, которые отличаются входными данными.
В первом случае многоугольник задаётся набором прямых, а во втором - вершинами.
Обход вершин многоугольника должен быть против часовой стрелки.
</p>
<p>Следующий алгоритм находит окружность в худшем случае за время O(n<sup>2</sup>), но обычно быстрее,
чем предыдущий. 
Вначале функция у которой параметром является массив вершин многоугольника ищёт перспективную вершину 
и начиная с неё определяет параметры прямых проходящие через рёбра.
Затем вызывается функция у которой параметром является массив прямых. 
Там выбирается первое и последнее ограничения, и находится максимальная окружность, 
которая касается этих ограничений и лежит в многоугольнике. При этом определяется третье касательное ограничение. 
Если эти три ограничения образуют закрытый треугольник, значит найденная окружность является максимальной 
для всего многоугольника и на этом алгоритм заканчивается.
Иначе часть рёбер отбрасывается и цикл повторяется.
</p>
<pre>
Def&lt;Circle2d> maxCircleInConvexPolygon ( CCArrRef< Line2d > &, nat & i1, nat & i2, nat & i3 );
Def&lt;Circle2d> maxCircleInConvexPolygon ( CCArrRef< Line2d > & line );
Def&lt;Circle2d> maxCircleInConvexPolygon ( CCArrRef&lt;Vector2d> & vert );
</pre>
<p>
В приложении <a href="demo/demo.html">DEMO</a> можно посмотреть результат вписания.
</p>
<p>
<p>Описание классов Line2d и Circle2d находится <a href="figure2d.html">здесь</a>.
<br>Описание шаблона классов CArrRef находится <a href=array.html>здесь</a>.
<br>Описание шаблона классов Def находится <a href="def.html">здесь</a>.
<br>Описание класса Vector2d находится <a href="rus_vector2d.html">здесь</a>.
<br>Исходники алгоритмов находятся в файле <a href="source/source.zip">opti2d.cpp</a>.
</p>
<a href="opti2d.html">Наверх</a>
<pre>

</pre></td></div>
</table>
</body>
</html>
