<html>
<head><title>Порядковые статистики</title><link rel="stylesheet" type="text/css" href="stylle.css"></head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center"><center>
<table width="800" cellspacing="0" cellpadding="0">
<div align=center><br>
<font color="" style="font-size: 20pt">Порядковые статистики</font>
</div><td><br>
<p>Рассмотрим такую задачу: дано множество из n чисел; нужно найти тот его элемент, который будет
i-м по счёту, если расположить элементы множества в порядке возрастания. 
Такой элемент называется i-ой порядковой статистикой.
Будем нумеровать элементы в стиле языка С. Тогда минимум - это нулевая порядковая статистика, а максимум -
это (n-1)-ая порядковая статистика. Медианой называется порядковая статистика номер n/2. 
Известно, что порядковую статистику можно найти за время O ( n ). 
Функция selectR делает это в среднем ( в худшем случае за O ( n<sup>2</sup> ) ), а функция select7 и в худшем случае:
</p>
<pre>Def&lt;double> select7 ( CArrRef&lt;double> a, nat i );

template &lt;class T> Def&lt;T> selectR ( CArrRef&lt;T> a, nat i );
</pre>
<p>Функция select7 использует поиск <a href="rus_median7.html">медианы семи чисел</a>,
а функция selectR <a href="rus_rand.html">псевдослучайные числа</a>.
Сравнительные тесты показали, что selectR обычно работает быстрее, чем select7.
</p>
<p>Следующая функция select осуществляет частичную сортировку исходного массива:
<pre>
template &lt;class T> bool select ( ArrRef&lt;T> a, nat i );
</pre>
После её применения выполняется условие:
<br>если j < i, то a[j] <= a[i],
<br>если j > i, то a[j] >= a[i].
<br>Сравнительные тесты показали, что select работает быстрее, чем selectR.
</p>
<p>Каждому числу можно сопоставить вес ( неотрицательное число ), тогда порядок будет определять число p,
значение которого находится в интервале от 0 до 1. 0 - соответствует минимуму, 1 - максимуму, 1/2 - медиане, а вообще
нужно найти число такое, чтобы сумма весов чисел меньших его делённая на общий вес была меньше или равна p, а
сумма весов чисел больших его делённая на общий вес была меньше или равна 1 - p. 
Таким образом определяются взвешенные порядковые статистики. 
Здесь необязательно, чтобы сумма всех весов была равна 1.
Следующая функция находит заданную взвешенную статистику и возвращает результат в виде индекса, 
что в некоторых случаях удобнее:
<pre>
template &lt;class T1, class T2> 
Def&lt;nat> selectR ( CArrRef&lt;T1> a, CArrRef&lt;T2> w, double p, ArrRef&lt;nat> buf );
</pre>
В этой функции члены массива а с нулевым весом игнорируются, а в случае обнаружения отрицательных весов функция
завершает работу и возвращает неопределённое значение. Размер вспомогательного массива buf должен быть не меньше,
чем удвоенный размер массива а.
</p>
<p>Следующие две функции вычисляют сглаженные порядковые статистики, т.е. функция от p получается гладкая ( без скачков ).
Функция selectS применяет прямоугольную функцию сглаживания, а функция selectT - треугольную:
<pre>Def&lt;double> selectS ( ArrRef&lt;SortItem&lt;double> > s, double p, double r );
Def&lt;double> selectT ( ArrRef&lt;SortItem&lt;double> > s, double p, double r );
</pre>
Здесь, как и выше, 0 <= p <= 1, а r - радиус окна усреднения. Элементы массива s в поле head содержат порядок, 
а в поле tail - вес. После вызова этой функции массив s будет упорядочен по возрастанию.
</p>
На рисунке ниже показаны 3 графика ( функции от р ) - selectR ( красный ), selectS ( синий ) и selectT ( зелёный ):
<br>
<br><center><img src="select.png"></center><br>
На графике selectR вертикальные отрезки изображены условно ( на самом деле там разрывы горизонтальных отрезков ).
Графики selectS и selectT не имеют разрывов, но функция selectS имеет разрывы первой производной, а у функции
selectT первая производная непрерывна. Радиус окна усреднения r = 1/16.
<p>Описание шаблонов классов CArrRef, ArrRef и CmbArray находятся <a href=array.html>здесь</a>.
<br>Описание шаблона классов SortItem находится <a href="sortitem.html">здесь</a>.
<br>Описание шаблона классов Def находится <a href="def.html">здесь</a>.
<br>Исходники находятся в файле <a href="source/source.zip">func1d.cpp</a>.
</p>
<a href="rus_sort.html">Наверх</a>
</td></table>
<pre>

</pre>
</body>
</html>