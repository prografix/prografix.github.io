<html>
<head><title>Выпуклая оболочка в пространстве</title>
<link rel="stylesheet" type="text/css" href="stylle.css"></head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center"><center>
<table width="800" cellspacing="0" cellpadding="0">
<div align=center><br>
<font color="" style="font-size: 20pt">Выпуклая оболочка в пространстве</font>
</div>
<br><div align=left><td>
<p>Дано дискретное множество точек в пространстве и надо построить выпуклую оболочку этих точек.
Результатом построения выпуклой оболочки будет многогранник. 
В данном алгоритме все грани многогранника будут треугольными:
<pre>
Polyhedron & convexHull ( CCArrRef&lt;Vector3d> & point, Polyhedron & poly );
</pre>
<p>В начале программы строится простейшая трёхмерная фигура - тетраэдр. 
В качестве первой вершины этого тетраэдра выбирается точка, самая удалённая от центра координат. 
Вторая вершина - это точка самая удалённая от первой. Третья вершина - это точка самая удалённая от 
прямой, проходящей через первые две точки. Четвёртая вершина - это точка самая удалённая от плоскости,
проходящей через первые три точки. Если входные точки лежат на одной плоскости, 
то программа останавливается и возвращает пустую модель. 
Иначе все вершины тетраэдра принадлежат выпуклой оболочке.
</p><p>Вычисляем центр сферы вписанной в тетраэдр. Далее все точки попавшие внутрь тетраэдра игнорируются,
а остальные распределяются по граням тетраэдра, в зависимости от того куда попадёт луч выпущенный из центра вписанной сферы 
и проходящий через данную точку.
<br>Для каждой грани тетраэдра вычисляется самая удалённая точка из приналежащих ей, и если такая точка есть,
то грань ставится в очередь с приоритетом, где приоритетом является расстояние до самой удалённой точки делённое
на абсолютное расстояние от плоскости грани до центра вписанной сферы. 
</p><p>Далее в цикле из очереди выбирается грань с максимальным приоритетом. Она делится на три грани при помощи
максимально-удалённой точки. Эта точка принадлежит выпуклой оболочке. 
Осташиеся внешние точки выбранной грани распределяются среди новых граней.
В результате этого разбиения в многограннике могут появиться невыпуклости. Они устраняются, рассматривая соседние
треугольники и в случае необходимоти перестраивая их.
Все изменённые грани выбираются из очереди и, если у них есть внешние точки, то для них вычисляется новый приоритет,
и грань ставится в очередь. Выпуклая оболочка будет готова, когда очередь опустеет.
</p>
<p>Время работы алгоритма для точек равномерно-распределённых на сфере равно O ( n * log<sup>2</sup> ( n ) ).
</p>
<p>Если в результате нужены только плоскости или вершины выпуклой оболочки, то для этого есть отдельные функции:
<pre>
DynArrRef<Plane3d> & convexHull ( CCArrRef&lt;Vector3d> & point, DynArrRef&lt;Plane3d> & plane );

DynArrRef<Vector3d> & convexHull ( CCArrRef&lt;Vector3d> & point, DynArrRef&lt;Vector3d> & vert );
</pre>
<p>Следующий алгоритм строит выпуклую оболочку многогранника:
<pre>
Polyhedron & convexHull ( const Polyhedron & inner, Polyhedron & outer );
</pre>
Этот алгоритм, по возможности, старается сохранить грани исходного многогранника.
В частности, если исходный многогранник выпуклый, то результирующий будет таким же.
</p>
<p>Следующая функция определеяет - является ли многогранник выпуклым:
<pre>
bool isConvex ( const Polyhedron & poly );
</pre>
</p>
<p>Смотрите описания: <a href=array.html>CArrRef и DynArrRef</a>, <a href="rus_polyhedron.html">Polyhedron</a>, 
<a href="rus_vector.html">Vector3d</a>, <a href="figure3d.html">Plane3d</a>.
</p>
<p>Исходники находятся в файле <a href="source/source.zip">func3d.cpp</a>.</p>
<a href="rus_geom.html">Наверх</a>
<pre>

</pre>
</td></div>
</table>
</body>
</html>
