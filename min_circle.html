<html>
<head><title>Минимальная охватывающая окружность</title>
<link rel="stylesheet" type="text/css" href="stylle.css"></head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align=center>
<table width=800 cellspacing=0 cellpadding=0>
<br>
<div align=center>
<font color="" style="font-size: 20pt">Минимальная охватывающая окружность</font>
</div>
<div align=left><td>
<p>
<br>Дано конечное множество точек на плоскости. Нужно найти окружность минимального радиуса такую, 
чтобы данные точки были внутри неё. Следующая функция находит такую окружность:
<pre>Def&lt;Circle2d> minCircleAroundPoints ( CArrRef&lt;Vector2d> data, DynArrRef&lt;nat> * index = 0 );
</pre>
Здесь data - это массив входных точек, а index - указатель на массив, в который будут записаны индексы
точек по которым была построена окружность ( в том случае, если указатель не равен 0 ).
<br><br>Описание алгоритма:
<br>1. Если к-во входных точек равно 0, то возвращаем неопределённую окружность.
<br>2. Если к-во входных точек равно 1, то возвращаем окружность с центром в этой точке и нулевым радиусом.
<br>3. Если к-во входных точек равно 2, то возвращаем окружность с центром в середине между этими точками и 
соответсвующим радиусом.
<br>4. Находим самую удалённую точку от первой. Если это расстояние будет равно 0, то возвращаем окружность 
с центром в первой точке и нулевым радиусом. Иначе считаем эти точки опорными и строим по ним окружность,
как в пункте 3.
<br>5. Начало цикла.
<br>6. Находим самую удаленную точку от центра текущей окружности. Если это расстояние не больше, чем радиус
текущей окружности или индекс самой удалённой точки равен одному из индексов опорных точек, то выходим из цикла.
Иначе будем включать эту точку в число опорных, а пока назовём её новой.
<br>7. Найдём среди опорных точек самую удаленную от новой точки и построим текущую окружность по двум точкам 
( новой и найденной ). 
<br>8. Если к-во опорных точек текущей окружности было равным 3, то переходим к пункту 9.
Иначе проверим выходит ли неиспользованная опорная точка за пределы текущей окружности. 
Если не выходит, то заменяем её на новую точку ( к-во опорных точек останется 
равным 2 ). Иначе добавляем новую точку в опорные и строим окружность по трём точкам.
Переходим к пункту 10.
<br>9. Находим из двух неиспользованных точек самую удаленную от центра текущей окружности. 
Если эта точка лежит вне круга, то она будет третьей опорной и тогда строим окружность по трём новым опорным точкам.
Иначе опорных точек останется две.
<br>10. Если радиус окружности не вырос за время цикла, то конец алгоритма, иначе идём на начало цикла.
</p>
<p>Дано конечное множество окружностей на плоскости. Нужно найти окружность минимального радиуса такую, 
чтобы все данные окружности были внутри неё. Следующая функция находит такую окружность:
<pre>Def&lt;Circle2d> minCircleAroundCircles ( CArrRef&lt;Circle2d> data );
</pre>
Описание этого алгоритма аналогично описанию алгоритма для точек.
</p>
<p>Дано конечное множество прямых на плоскости. Нужно найти окружность минимального радиуса такую, 
чтобы она пересекала все данные прямые. Следующая функция находит такую окружность:
</p>
<pre>Def&lt;Circle2d> minCircle ( CArrRef&lt;Line2d> data );
</pre>
Описание шаблонов классов CArrRef и DynArrRef находится <a href=array.html>здесь</a>.
<br>Описание шаблона классов Def находится <a href="def.html">здесь</a>.
<br>Описание класса Vector2d находится <a href="rus_vector2d.html">здесь</a>.
<br>Описание классов Line2d и Circle2d находится <a href="figure2d.html">здесь</a>.
<br>
<br>В приложении <a href="demo/demo.html">DEMO</a> можно посмотреть работу этих алгоритмов.
<br>Исходники алгоритма находятся в файле <a href="source/source.zip">opti2d.cpp</a>.
<br><br><a href="opti2d.html">Наверх</a>
<pre>

</pre>
</div></td>
</table>
</div>
</body>
</html>
