<html>
<head><title>Минимальная охватывающая фигура в пространстве</title>
<link rel="stylesheet" type="text/css" href="stylle.css">
</head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center"><center>
<table width="800" cellspacing="0" cellpadding="0">
<div align=center><br>
<font color="" style="font-size: 20pt">Минимальная охватывающая фигура в пространстве</font>
</div>
<div align=left><td><br>
<p>В этом разделе представлены функции, которые находят минимальную фигуру охватывающую данное множество точек в трёхмерном пространстве.</p>
<p>&bull; Сфера и конечное множество точек.
<pre>Def&lt;Sphere3d> minSphereAroundPoints ( CArrRef&lt;Vector3d> data );
</pre>
Описание этого алгоритма:
<br>1. Если к-во входных точек равно 0, то возвращаем неопределённую сферу.
<br>2. Если к-во входных точек равно 1, то возвращаем сферу с центром в этой точке и нулевым радиусом.
<br>3. Если к-во входных точек равно 2, то возвращаем сферу с центром в середине между этими точками и 
соответсвующим радиусом.
<br>4. Находим самую удалённую точку от первой. Если это расстояние будет равно 0, то возвращаем сферу 
с центром в первой точке и нулевым радиусом. Иначе считаем эти точки опорными и строим по ним сферу,
как в пункте 3.
<br>5. Начало цикла.
<br>6. Находим самую удаленную точку от центра текущей сферы. Если это расстояние не больше, чем радиус
текущей сферы или индекс самой удалённой точки равен одному из индексов опорных точек, то выходим из цикла.
Иначе будем включать эту точку в число опорных, а пока назовём её новой.
<br>7. Найдём среди старых опорных точек и новой точки путём перебора новый набор опорных точек 
( их будет не более четырёх ) и минимальную сферу вокруг них. 
<br>8. Если радиус текущей сферы не вырос за время цикла, то конец алгоритма, иначе идём на начало цикла.
</p>
<p>&bull; Сфера и конечное множество сфер.
<pre>Def&lt;Sphere3d> minSphereAroundSpheres ( CArrRef&lt;Sphere3d> data );
</pre>
Описание этого алгоритма аналогично описанию алгоритма для точек.
</p>
<p>&bull; Сфера пересекающая все данные плоскости или прямые:
<pre>Def&lt;Sphere3d> minSphere ( CArrRef&lt;Plane3d> data );
Def&lt;Sphere3d> minSphere ( CArrRef&lt;Line3d> data );
</pre>
Временная сложность этих алгоритмов практически линейная.
</p>
<p>&bull; Эллипсоид и конечное множество точек. Минимум объёма.
<pre>Def&lt;Ellipsoid3d> minEllipsoidV ( CArrRef&lt;Vector3d> point );
</pre>
</p>
<p>&bull; Цилиндр и конечное множество точек. Минимум радиуса.
<pre>Def&lt;Cylinder3d> minCylinderR ( CArrRef&lt;Vector3d> point );
</pre>
</p>
<p>&bull; Правильный тетраэдр охватывающий данные точки без вращения.
<pre>bool minRegularTetrahedronAroundPointsNR ( СCArrRef&lt;Vector3d> & data, 
                                           const Ortho3d & ortho, Polyhedron & poly );
</pre>
</p>
<p>&bull; Правильный тетраэдр охватывающий данные точки.
<pre>bool minRegularTetrahedronAroundPoints ( СCArrRef&lt;Vector3d> & data, Polyhedron & poly );
</pre>
</p>
<p>&bull; Прямоугольный параллелепипед охватывающий данные точки без вращения.
<pre>Def&lt;Cuboid3d> minCuboidAroundPointsNR ( CArrRef&lt;Vector3d> data );
</pre>
</p>
<p>&bull; Прямоугольный параллелепипед и внутренний многогранник.
Минимум по объёму ( V ) и по площади поверхности ( A ):
<pre>
Def&lt;Cuboid3d> minCuboidAroundConvexPolyhedronV ( const Polyhedron & inner );

Def&lt;Cuboid3d> minCuboidAroundConvexPolyhedronA ( const Polyhedron & inner );
</pre>
Временная сложность этих алгоритмов опытным путём определена, как O ( n<sup>2</sup> log ( n ) ),
где n - это к-во рёбер ( вершин или граней ) многогранника ( inner ).
<br>Если же нужно найти минимальный прямоугольный параллелепипед охватывающий данный набор точек, то тогда
надо вначале получить <a href="rus_convex3d.html">выпуклую оболочку</a> этих точек, а затем для выпуклой оболочки
найти минимальный охватывающий параллелепипед.
</p>
<p>Примеры использования этих функций можно посмотреть в приложении <a href="demo/demo.html">DEMO</a>.
</p>
<p>Описание шаблона классов CArrRef находится <a href=array.html>здесь</a>.
<br>Описание шаблона классов Def находится <a href=def.html>здесь</a>.
<br>Описание класса Vector3d находится <a href="rus_vector.html">здесь</a>.
<br>Описание классов Sphere3d, Ellipsoid3d, Cylinder3d и Cuboid3d находится <a href="figure3d.html">здесь</a>.
<br>Описание класса Polyhedron находится <a href="rus_polyhedron.html">здесь</a>
<br>Исходники находятся в файле <a href="source/source.zip">opti3d.cpp</a>.
</p> 
<a href="rus_geom.html">Наверх</a>
</pre>

<pre>
</td></div>
</table>
</body>
</html>
