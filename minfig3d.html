<html>
<head><title>Минимальная охватывающая фигура в пространстве</title>
<link rel="stylesheet" type="text/css" href="stylle.css">
</head>
<body bgcolor=#eeeeba MARGINWIDTH=0 MARGINHEIGHT=0 link=#0000F0 alink=#aaaaFF vlink=#339900>
<div align="center"><center>
<table width="800" cellspacing="0" cellpadding="0">
<div align=center><br>
<font color="" style="font-size: 20pt">Минимальная охватывающая фигура в пространстве</font>
</div>
<div align=left><td><br>
<p>Дано конечное множество точек в трёхмерном пространстве. Нужно построить сферу минимального радиуса такую, 
чтобы все данные точки лежали внутри сферы. Следующая функция находит такую сферу:
<pre>Def&lt;Sphere3d> minSphereAroundPoints ( CArrRef&lt;Vector3d> data );
</pre>
Описание этого алгоритма:
<br>1. Если к-во входных точек равно 0, то возвращаем неопределённую сферу.
<br>2. Если к-во входных точек равно 1, то возвращаем сферу с центром в этой точке и нулевым радиусом.
<br>3. Если к-во входных точек равно 2, то возвращаем сферу с центром в середине между этими точками и 
соответсвующим радиусом.
<br>4. Находим самую удалённую точку от первой. Если это расстояние будет равно 0, то возвращаем сферу 
с центром в первой точке и нулевым радиусом. Иначе считаем эти точки опорными и строим по ним сферу,
как в пункте 3.
<br>5. Начало цикла.
<br>6. Находим самую удаленную точку от центра текущей сферы. Если это расстояние не больше, чем радиус
текущей сферы или индекс самой удалённой точки равен одному из индексов опорных точек, то выходим из цикла.
Иначе будем включать эту точку в число опорных, а пока назовём её новой.
<br>7. Найдём среди старых опорных точек и новой точки путём перебора новый набор опорных точек 
( их будет не более четырёх ) и минимальную сферу вокруг них. 
<br>8. Если радиус текущей сферы не вырос за время цикла, то конец алгоритма, иначе идём на начало цикла.
</p>
<p>Дано конечное множество сфер в трёхмерном пространстве. Нужно найти сферу минимального радиуса такую, 
чтобы все данные сферы были внутри неё. Следующая функция находит такую сферу:
<pre>Def&lt;Sphere3d> minSphereAroundSpheres ( CArrRef&lt;Sphere3d> data );
</pre>
Описание этого алгоритма аналогично описанию алгоритма для точек.
</p>
<p>Следующие две функции находят сферу минимального радиуса такую, 
что она пересекает все данные плоскости или прямые:
</p>
<pre>Def&lt;Sphere3d> minSphere ( CArrRef&lt;Plane3d> data );
Def&lt;Sphere3d> minSphere ( CArrRef&lt;Line3d> data );
</pre>
<p>Временная сложность этих алгоритмов практически линейная.
</p>
<p>Если нужно построить минимальный по объёму эллипсоид охватывающий заданные точки, то можно воспользоваться
следующей функцией:
</p>
<pre>Def&lt;Ellipsoid3d> minEllipsoidV ( CArrRef&lt;Vector3d> point );
</pre>
<p>Входным параметром для функции minEllipsoidV является ссылка на массив точек point.
Возвращаемое значение - это объект содержащий параметры эллипсоида.
</p>
<p>Следующая функция находит цилиндр минимального радиуса охватывающий заданные точки:
</p>
<pre>Def&lt;Cylinder3d> minCylinderR ( CArrRef&lt;Vector3d> point );
</pre>
<p>Следующая функция находит минимальный правильный тетраэдр охватывающий данные точки без вращения:
<pre>bool minRegularTetrahedronAroundPointsNR ( CArrRef&lt;Vector3d> data, Polyhedron & poly );
</pre>
Следующая функция находит минимальный параллелепипед охватывающий данные точки без вращения:
<pre>Def&lt;Cuboid3d> minCuboidAroundPointsNR ( CArrRef&lt;Vector3d> data );
</pre>
Теперь рассмотрим получение минимального прямоугольного параллелепипеда ( outer ) охватывающего
данный выпуклый многогранник ( inner ). Минимум будем искать по объёму ( V ) и по площади поверхности ( A ):
<pre>
Def&lt;Cuboid3d> minCuboidAroundConvexPolyhedronV ( const Polyhedron & inner );

Def&lt;Cuboid3d> minCuboidAroundConvexPolyhedronA ( const Polyhedron & inner );
</pre>
Временная сложность алгоритмов поиска минимального прямоугольного параллелепипеда опытным путём определена,
как O ( n<sup>2</sup> log ( n ) ),
где n - это к-во рёбер ( вершин или граней ) многогранника ( inner ).
<br>Если же нужно найти минимальный прямоугольный параллелепипед охватывающий данный набор точек, то тогда
надо вначале получить <a href="rus_convex3d.html">выпуклую оболочку</a> этих точек, а затем для выпуклой оболочки
найти минимальный охватывающий параллелепипед.
</p>
<p>Примеры использования этих функций можно посмотреть в приложении <a href="demo/demo.html">DEMO</a>.
</p>
<p>Описание шаблона классов CArrRef находится <a href=array.html>здесь</a>.
<br>Описание шаблона классов Def находится <a href=def.html>здесь</a>.
<br>Описание класса Vector3d находится <a href="rus_vector.html">здесь</a>.
<br>Описание классов Sphere3d, Ellipsoid3d, Cylinder3d и Cuboid3d находится <a href="figure3d.html">здесь</a>.
<br>Описание класса Polyhedron находится <a href="rus_polyhedron.html">здесь</a>
<br>Исходники находятся в файле <a href="source/source.zip">opti3d.cpp</a>.
</p> 
<a href="rus_geom.html">Наверх</a>
</pre>

<pre>
</td></div>
</table>
</body>
</html>
